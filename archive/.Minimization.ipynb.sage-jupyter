{"kernelspec":{"display_name":"Python 2 (Ubuntu, plain)","language":"python","name":"python2-ubuntu"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::e524812a-4391-4403-b041-fdda9c2dd3b6","text/plain":"<IPython.core.display.HTML object>"},"metadata":{},"output_type":"display_data"},{"data":{"application/javascript":"smc-blob::af3dc0c4-87ab-4e89-bdf8-f221d33e1dda","text/plain":"<IPython.core.display.Javascript object>"},"metadata":{},"output_type":"display_data"},{"data":{"text/html":"smc-blob::540c5d05-cc63-4445-a155-e438df6294f7","text/plain":"<IPython.core.display.HTML object>"},"metadata":{},"output_type":"display_data"}],"source":"import mmf_setup;mmf_setup.nbinit()"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# Minimization"}
{"cell_type":"markdown","metadata":{},"source":"Here we demonstrate some properties and problems with minimization techniques to find the ground state.\n\nRecall that the GPE follows from minimizing the following energy $E$ at fixed total particle number $N$:\n\n$$\n  E[\\psi] = \\int \\d^{d}{x} \\left(\n    \\frac{\\abs{-\\I\\hbar \\vect\\nabla \\psi(x)}^2}{2m}\n    + \\frac{g}{2}n(x)^2\n    + V(x)n(x)\n  \\right), \\qquad\n  N = \\int \\d^{d}{x} n(x), \\qquad\n  n(x) = \\psi^\\dagger(x)\\psi(x)\\\\\n  \\op{H}\\psi(x) = \\pdiff{E[\\psi]}{\\psi^\\dagger(x)}.\n$$\n\nNumerically, integrals are performed by summing over the lattice points, and include a factor of the metric $\\d{x}^d$ which we call `metric` in the code and must be explicitly included in the minimizer.\n\nThus, we can formulate the problem as a minimization of the objective function\n\n$$\n  f(x) = E[\\psi], \\qquad N[x] = N_0, \\qquad x = P(\\psi)\n$$\n\nwhere $x = P(\\psi)$ is a real parametrization of $\\psi$ (i.e. the real and imaginary components in some order.  We use the underlying memory layout to efficiently do this conversion).  The minimizer requires the gradient, so se have:\n\n$$\n  \\nabla f(x) = P\\left(\\mat{H}\\psi\\right)(2\\d{x}^d).\n$$\n\nThe last factor of `2*metric` accounts for the complex-to-real conversion and the metric implicit in the summation of the integral.."}
{"cell_type":"markdown","metadata":{},"source":"As we shall see below, we will also need to be able to minimize an auxilliary funtion:\n\n$$\n  g(x) = (\\psi\\mat{H})^\\dagger (\\mat{H}\\psi).\n$$\n\nThis requires a little care since $\\mat{H}[n]$ itself depends non-linearly on the $\\psi$ through the density $n$.  Let us consider a slightly more general non-linear energy density:\n\n$$\n  \\frac{g}{2}{n(x)^2 = \\mathcal{E}(n)\n$$\n\nThe only portion of $\\op{H}$ that depends on $n$ is $[H]_{ij} = \\cdots + \\mathcal{E}'(n_j)\\delta_{ij}$, so the derivative is:\n\n$$\n  \\pdiff{[H]_{ij}}{n_k} = g\\delta_{ij}\\delta_{jk}.\n$$\n\nThe resulting derivative contains the piece \n\n$$\n  \\pdiff{g}{\\psi^\\dagger_k} = [\\mat{H}^\\dagger\\mat{H}\\psi]_k\n    + \\sum_{ij}\\psi^\\dagger_i\\mathcal{E}''(n_j)\\psi_j\\delta_{jk}\\delta_{ij}[\\mat{H}\\psi]_j\n    + \\sum_{ij}[\\psi^\\dagger\\mat{H}^\\dagger]_i\\mathcal{E}''(n_j)\\psi_j\\delta_{jk}\\delta_{ij}\\psi_j    \n  =  [\\mat{H}^\\dagger\\mat{H}\\psi]_k\n    + \\psi^\\dagger_k\\mathcal{E}''(n_k)\\psi_k[\\mat{H}\\psi]_k\n    + [\\psi^\\dagger\\mat{H}^\\dagger]_k\\mathcal{E}''(n_k)\\psi_k\\psi_k\n$$\n\n$$\n  \\pdiff{g}{\\psi^\\dagger_k} = [\\mat{H}^\\dagger\\mat{H}\\psi]_k + n_k\\mathcal{E}''(n_k)\\psi_k\n$$"}
{"cell_type":"markdown","metadata":{},"source":"## Harmonic Oscillator"}
{"cell_type":"markdown","metadata":{},"source":"As a simple test, we consider a simple harmonic oscillator setting $V(x) = m\\omega^2x^2/2$ and $g=0$ which has a ground state wavefunction:\n\n$$\n  \\psi_0(x) = \\frac{1}{\\pi^{1/4}\\sqrt{a}} e^{-x^2/2a^2}, \\qquad\n  a = \\sqrt{\\frac{\\hbar}{m\\omega}}.\n$$\n\nTo ensure we have a sufficiently large box, we choose $L$ so that the density falls by a factor of $10^{-15}$ at the boundary.  This will ensure that we have no long-range (IR) errors.\n\n$$\n  n(L/2) = e^{-L^2/4a^2} \\approx 2^{-52} \\approx 2\\times 10^{-16} \\approx e^{-36},\\qquad\n  L \\approx 12.0 a.\n$$"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n"},{"name":"stderr","output_type":"stream","text":"bec.py:96: RuntimeWarning: invalid value encountered in true_divide\n  n = np.maximum(0, (self.mu - V_ext))/self.g\n"},{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7f98ee7874d0>"},"execution_count":2,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::44aa9f6c-8e44-469a-95f2-9fba25b76338","text/plain":"<matplotlib.figure.Figure at 0x7f98ee85ab10>"},"metadata":{},"output_type":"display_data"}],"source":"%pylab inline --no-import-all\nimport bec;reload(bec)\nfrom bec import u\ndim = 1\nw = 1.0\na = np.sqrt(u.hbar/u.m/w)\nN = 32\nL = 12*a\nE0 = dim * u.hbar * w / 2.0\n\ndef get_analytic_state(N=N, L=L):\n    \"\"\"Return the analytic ground state.\"\"\"\n    s = bec.State(Nxyz=(N,)*dim, Lxyz=(L,)*dim, ws=(w,)*dim, g=0.0, N=1.0)\n    r2 = sum(_x**2 for _x in s.xyz)\n    s[...] = np.sqrt(np.exp(-r2/a**2)/np.sqrt(np.pi)/a)\n    return s\n\nNs = 2**np.arange(1,8)\nEs = np.array([get_analytic_state(_N).get_energy() for _N in Ns])\nEs_ = np.array([get_analytic_state(_N, L=L/1.1).get_energy() for _N in Ns])\nplt.semilogy(Ns, abs(Es - E0), '-+', label='L/a = {}'.format(L/a))\nplt.semilogy(Ns, abs(Es_ - E0), 'r--+', label='L/a = {}'.format(L/a/1.2))\nplt.xlabel('N')\nplt.ylabel('err (E)')\nplt.legend(loc='best')"}
{"cell_type":"markdown","metadata":{},"source":"The errors here are due to an insufficient number of lattice points $N$ or too large of a lattice spacing $\\d{x}$ (ultraviolet or UV errors).  Notice that the error decreases exponentially as a function of the lattice size, reaching machine precision at $N=32$:\n\n$$\n  \\delta E \\propto a^{-N} \\propto (\\d{x})^{N}.\n$$\n\nThis exponential convergence is a special property of Fourier methods for analytic functions.  Finite-difference methods exhibit at best a power-law scaling $\\delta E \\propto N^{a}$ (though higher-order methods can have fairly large exponents).  The other curve shows a slightly smaller box, demonstrating that $L=12a$ is required for full convergence (infrared or IR errors)."}
{"cell_type":"markdown","metadata":{},"source":"### Exercise: Explain UV Errors"}
{"cell_type":"markdown","metadata":{},"source":"I explained above why $L=12a$ was required to reduce the errors to machine precision.  Explain why $N=32$ is sufficient for this purpose."}
{"cell_type":"markdown","metadata":{},"source":"## Minimization"}
{"cell_type":"markdown","metadata":{},"source":"Having established that we can achieve machine precision in the energy, let's see how well the minimization routine can do."}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import minimize;reload(minimize);from minimize import Minimize\ns0 = get_analytic_state()\n\ndef get_sol(N=32, ftol=1e-12, gtol=1e-12):\n    s = get_analytic_state(N=N)\n    s[...] = np.sqrt(1./np.prod(s.Lxyz))   # Start with a constant density initial state\n    s1 = Minimize(s).minimize(fix_N=True, ftol=ftol, gtol=gtol)[0]\n    return s1"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7f98cf204050>"},"execution_count":5,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::c53c0cb6-79e0-497f-8d9c-e81b42debbcc","text/plain":"<matplotlib.figure.Figure at 0x7f98cf2e3f90>"},"metadata":{},"output_type":"display_data"}],"source":"tols = 10.0**np.arange(-1, -16, -1)\ndEs_f = []\ndEs_g = []\ndns_f = []\ndns_g = []\nfor _t in tols:\n    _sf = get_sol(ftol=_t, gtol=1e-32)\n    _sg = get_sol(gtol=_t, ftol=1e-32)\n    dEs_f.append(abs(_sf.get_energy() - E0))\n    dEs_g.append(abs(_sg.get_energy() - E0))\n    dns_f.append(abs(abs(_sf[...])**2 - abs(s0[...])**2).max())\n    dns_g.append(abs(abs(_sg[...])**2 - abs(s0[...])**2).max())    \n\nplt.loglog(tols, dEs_f, 'r+-', label='ftol (E)')\nplt.loglog(tols, dEs_g, 'g+-', label='gtol (E)')\nplt.loglog(tols, dns_f, 'r+--', label='ftol (n)')\nplt.loglog(tols, dns_g, 'g+--', label='gtol (n)')\n\nplt.xlabel('tol')\nplt.ylabel('err')\nplt.legend(loc='best')"}
{"cell_type":"markdown","metadata":{},"source":"Here we note several things.  First - the energy can be computed to machine precision, which requires `ftol`$\\sim\\epsilon$ and `gtol`$\\sim \\sqrt{\\epsilon}$, however, the state itself can only be computed to an absolute accuracy of $\\sqrt{\\epsilon}$ because at this point, the energy no-longer changes.  This is a common problem with minimization proceedures.  About the minimium, the function is quadratic $f(x) \\approx f_0 + a (x-x_0)^2$ so changes in $x \\sim \\delta$ will give rise to changes in $f(x_0+\\delta) \\approx f_0 + a\\delta^2$."}
{"cell_type":"markdown","metadata":{},"source":"To improve the situation, we can consider minimizing $\\norm{\\nabla{f}}$ instead of minimizing $f(x)$.  This is require that the state be stationary to machine precision."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}