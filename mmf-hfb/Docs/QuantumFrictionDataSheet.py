# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:light
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.4'
#       jupytext_version: 1.2.3
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

import mmf_setup;mmf_setup.nbinit()
import matplotlib.pyplot as plt
# %pylab inline --no-import-all
from nbimports import *
import numpy as np
from mmf_hfb.BCSCooling import BCSCooling
from mmf_hfb.Potentials import HarmonicOscillator
from mmf_hfb.SolverABM import ABMEvolverAdapter
from os.path import join
import inspect
import json
import glob
import os
from mmf_hfb.CoolingCaseTests import TestCase, Prob, Normalize, dict_to_complex, deserialize_object, load_json_data, random_gaussian_mixing


# +
def get_init_states(N=128, dx=0.1):
    b = BCSCooling(N=N, dx=dx)
    h = HarmonicOscillator()
    x = b.xyz[0]
    V = x**2/2
    H0 = b._get_H(mu_eff=0, V=0)
    H1 = b._get_H(mu_eff=0, V=V)
    U0, E0 = b.get_U_E(H0, transpose=True)
    U1, E1 = b.get_U_E(H1, transpose=True)
    psi_standing_wave=Normalize(U0[1],dx=dx)
    psi_gaussian_mixing = random_gaussian_mixing(x, dx=dx)
    psi_uniform = Normalize(U0[0], dx=dx)
    psi_bright_soliton = Normalize(np.exp(-x**2/2.0)*np.exp(1j*x), dx=dx)
    return dict(ST=psi_standing_wave, GM=psi_gaussian_mixing, UN=psi_uniform, BS=psi_bright_soliton)

def get_potentials(x):
    V0 = 0*x
    V_HO = x**2/2
    V_PO = V0 + np.random.random()*V_HO + abs(x**2)*np.random.random()
    return dict(V0=V0, HO=V_HO, PO=V_PO)


# -

# # Load Data from Files
# * load a saved json file that can be used to create testCase objects

res = load_json_data()
testCases = deserialize_object(res)
t0 = testCases[4]


# ## Visualization
# * some functions used to filter conditions

# +
def beta_filter(t, expr=None):
    t = t.b
    beta_0, beta_V, beta_K, beta_D, beta_Y =t.beta_0, t.beta_V, t.beta_K, t.beta_D, t.beta_Y 
    if expr is None:
        if t.beta_V >0 and t.beta_K==0 and t.beta_D==0 and t.beta_Y==0:
            return True
        return False
    else:
        return eval(expr)

def V_filter(t, expr=None):
    V = t.V_key
    if expr is None:
        if V == 'HO':
            return True
        return True
    else:
        return eval(expr)

def t_filter(t, expr=None):
    if expr is None:
        return True
    else:
        return eval(expr)

def filter(ts,t_expr=None, V_expr=None, beta_expr=None):
    filtered_ts = []
    for t in ts:
        if not beta_filter(t, expr=beta_expr):
            continue
        if not V_filter(t, expr=V_expr):
            continue
        if not t_filter(t, expr=t_expr):
            continue
            
        filtered_ts.append(t)
    return filtered_ts

def PN(psi):
    return Prob(Normalize(psi))


# -

ts = filter(testCases, t_expr='t.g==1', V_expr='V=="PO"', beta_expr="beta_V>0 and beta_K==0 and beta_D==0 and beta_Y==0")
def plotCase(t):
    plt.figure(figsize=(10, 5))
    plt.subplot(121)
    t.plot(0)
    plt.subplot(122)
    E0, Es, Ts, Tws = t0.E0, t.Es, t0.physical_time, t0.wall_time
    Es = np.array(Es) - E0
    Es = Es/E0
    plt.semilogy(Tws, Es, '--')


# # Test Code
# * code used to check results generated by the code in [CoolingCaseTests.py](CoolingCaseTests.py)

N=128
dx=0.2
g=-1
V_key = 'V0'
psis_init = get_init_states()
psi_init= psis_init['ST']
b = BCSCooling(N=N, dx=dx)
h = HarmonicOscillator()
x = b.xyz[0]
Vs = get_potentials(x)
args = dict(N=N, dx=dx, eps=1e-1, T_ground_state=20, V=Vs[V_key], V_key=V_key, g=g, psi_init=psi_init, use_abm=False, check_dE=False)
t=TestCase(ground_state_eps=1e-1, beta_0=1, **args)

plt.plot(x, PN(psi_init), "--", label='init')
plt.plot(x, PN(t.psi_ground), '-',label="final")

plt.figure(figsize=(18,5))
t.b.beta_V= 100
t.b.beta_K = 10
t.b.keta_Y = 0
t.run(T=5, plot=True, plot_log=False)
