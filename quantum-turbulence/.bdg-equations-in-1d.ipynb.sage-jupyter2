{"type":"cell","id":"0399b2","pos":49,"input":"We thus expect the error to scale like \n\n$$\n  \\delta_{IR} \\sim \\frac{\\d{k}^2}{24} = \\frac{\\pi^2}{3L^2}\n$$\n\nbut the coefficient is difficult to calculate.","cell_type":"markdown"}
{"type":"cell","id":"042e44","pos":27,"input":"We now generalize these results to finite temperature and allow for asymmetry.  Here we will obtain occupation numbers described by the Fermi distribution function\n\n$$\n  f(E) \\equiv f_\\beta(E) = \\frac{1}{1 + e^{\\beta E}} = \\frac{1-\\tanh(\\beta E/2)}{2}, \n  \\qquad \\beta = \\frac{1}{k_B T}, \\qquad\n  f(E) + f(-E) = 1,\n$$\n\nThe BdG equations follow from the single-particle Hamiltonian (assuming homogeneous states)\n\n$$\n  \\begin{pmatrix}\n    \\epsilon_k^{\\uparrow} & \\Delta\\\\\n    \\Delta & -\\epsilon_{-k}^{\\downarrow}\n  \\end{pmatrix}\n$$\n\n**where** \n\n$$\n  \\epsilon_k^{\\uparrow} = \\frac{k^2}{2m}  - \\mu_\\uparrow, \\\\\n  \\epsilon_{-k}^{\\downarrow} = \\frac{k^2}{2m} - \\mu_\\downarrow.\n$$\n\nwhich has eigenvectors and eigenvalues","cell_type":"markdown"}
{"type":"cell","id":"052475","pos":85,"input":"%pylab inline --no-import-all\nfrom scipy.optimize import leastsq\nL = 0.1\nkF = 20.0/L\nEF = kF**2/2\nmu = 9.5*EF\nt = 0.1*EF\nN = 2**8\nr_tol = 1e-4\nm = hbar = 1\nv_0 = N*np.pi**2/L/m*r_tol\n\nprint(mu, t)\n\nl = Lattice(T=0.0, N=N, L=L, v0=v_0, power=1, V0=-EF/40)\ntwists = np.linspace(-np.pi, np.pi, 40)\nks_b = twists/L\nEs0 = [np.linalg.eigvalsh(l.get_H(mus=(1.0, 0.0), delta=1.0, twist=_t)[:N,:N])[0]\n       for _t in twists]\nEs = [np.linalg.eigvalsh(l.get_H(mus=(1.0, 0.0), delta=1.0, twist=_t)[:N,:N])[1:3]\n      for _t in twists]\n\ndef f((t, E0)):\n    return 2*t*(1-np.cos(ks_b*L)) + E0 - Es0\n\n(t, E0), err = leastsq(f, ((max(Es0)-min(Es0))/2, min(Es0)))\n\nplt.figure(figsize=(10,5))\nplt.subplot(121)\nplt.plot(ks_b, Es0, '+')\nplt.plot(ks_b, f((t, E0)) + Es0)\n\nplt.subplot(122)\nplt.plot(ks_b, Es0, '+')\nplt.plot(ks_b, f((t, E0)) + Es0)\nplt.plot(ks_b, Es)\nprint(t)","cell_type":"code","exec_count":0}
{"type":"cell","id":"076a7c","pos":65,"input":"From the work of [A Bulgac, MMN Forbes, P Magierski](https://arxiv.org/abs/1008.3933) pp 41, and with a cutoff $k_c$, the relation betweem the scattering length $a$ and the potential strength can be written:\n\\begin{align}\n\\frac{m}{4\\pi\\hbar^2 a}\n&=\\frac{1}{g} + \\frac{1}{2}\\int_{0\\le k \\le k_c}\\frac{d^3k}{(2\\pi)^3}\\frac{1}{\\frac{\\hbar^2 k^2}{2m} +i0^+}\\\\\n&=\\frac{1}{g}+\\frac{m}{2\\hbar^2\\pi^2}k_c \\tag{83}\n\\end{align}","cell_type":"markdown"}
{"type":"cell","id":"0af16b","pos":87,"input":"class HomogeneousLattice(homogeneous.Homogeneous):\n    t = 0.1\n    L = 0.46\n\n    def get_es(self, k, mus_eff):\n        return (2*self.t*(1-np.cos(k*self.L)) - mus_eff[0],\n                k**2/2.0/m - mus_eff[1])\n\nh = HomogeneousLattice()\nv_0, (na, nb), (mua, mub) = h.get_BCS_v_n_e(delta=delta, mus_eff=mus_eff)","cell_type":"code","exec_count":0}
{"type":"cell","id":"0b7815","pos":107,"input":"plt.plot(np.sqrt(k2[:N])[1:-1:2], (abs(v[:,1:-1].reshape(N, N//2-1, 2))**2).sum(axis=-1).sum(axis=0)/N)","cell_type":"code","exec_count":0}
{"type":"cell","id":"0c7046","pos":0,"input":"# BdG Equations in 1D (HFB)\n\nHere we present some examples of solving the BdG equations (Hartree-Fock_Bogoliubov or HFB) for fermions in 1D.\n\nThe 1D system is not a very good model for physics (mean-field theory works better in higher dimensions) but contains all of the ingredients of the 3D theory in a form that can be quickly simulated.\n\n<!-- END_TEASER -->","cell_type":"markdown"}
{"type":"cell","id":"11c957","pos":50,"input":"### <font color='green'> Twist-Averaged Boundary Conditions(TBC)</font>","cell_type":"markdown"}
{"type":"cell","id":"1204b4","pos":57,"input":"L = 0.46\nN = 2**8\nN_twists = 2**np.arange(0,6)\n\nres = np.array([get_err(N=N, L=L, N_twist=N_twist)[0]\n                for N_twist in N_twists])\nplt.loglog(N_twists, abs(res[:,0] - n)/n, '--+', label='$n$')\nplt.loglog(N_twists, abs(res[:,1] - delta)/delta, '--o', label=r'$\\Delta$')\nplt.legend()","output":{"0":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7fdef13acd30>"},"output_type":"execute_result","exec_count":11},"1":{"data":{"image/png":"86861a8df7e81eaed7e87432de065829fcb46f20"},"metadata":{"image/png":{"height":251,"width":381}},"output_type":"execute_result","exec_count":11}},"cell_type":"code","exec_count":11}
{"type":"cell","id":"12058f","pos":44,"input":"$$\n  \\Delta = v_0 \\nu = \\frac{v_0}{2}\\int\\frac{\\d{k}}{2\\pi}\\;\\frac{\\Delta}{\\sqrt{\\epsilon_+^2 + \\Delta^2}},\\quad\n  n_+ = \\frac{N_a + N_b}{L} = \\int\\frac{\\d{k}}{2\\pi}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right],\\quad\n  \\epsilon_+ = \\frac{\\hbar^2k^2}{2m} - \\frac{1}{2}n_+v_0 - \\mu = \\frac{\\hbar^2k^2}{2m} - \\mu_{\\text{eff}},\\\\\n  \\frac{E}{L} = \n  \\int\\frac{\\d{k}}{2\\pi} \\frac{\\hbar^2k^2}{2m}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right]\n  - v_0(n_an_b + \\nu^\\dagger\\nu)\n  = \n  \\int\\frac{\\d{k}}{2\\pi} \\frac{\\hbar^2k^2}{2m}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right]\n  - \\frac{v_0 n_+^2}{4}\n  - \\frac{\\abs{\\Delta}^2}{v_0}.\n$$\n\n","cell_type":"markdown"}
{"type":"cell","id":"12a026","pos":99,"input":"k_bloch.max(), np.pi/L_cell","cell_type":"code","exec_count":0}
{"type":"cell","id":"1423c1","pos":37,"input":"$$\n  \\mat{H} = \\begin{pmatrix}\n    -\\frac{\\hbar^2 k^2}{2m} - \\mu_a +V_a & -\\Delta\\\\\n    -\\Delta^\\dagger & -\\left(-\\frac{\\hbar^2 k^2}{2m} - \\mu_b +V_b\\right)\n  \\end{pmatrix}, \\qquad\n  \\op{\\Psi} = \\begin{pmatrix}\n    \\op{a}_{k}\\\\\n    \\op{b}^\\dagger_{-k}\n  \\end{pmatrix}.\n$$\n\nThe application of the kinetic energy would be as follows:\n\n$$\n  \\DeclareMathOperator{\\FFT}{FFT}\n  \\psi(x) = \n  -\\frac{\\hbar^2\\nabla_x^2\\psi(x)}{2m} \n  = \\FFT^{-1}\\Bigl(\\frac{\\hbar^2k^2}{2m}\\overbrace{\\FFT(\\psi)}^{\\int \\d{x}\\; e^{-\\I k x}\\psi(x)}\\Bigr)\n  = \\int\\frac{\\d{k}}{(2\\pi)}\\; e^{\\I k x} \\Bigl(\\frac{\\hbar^2k^2}{2m} \\int\\d{y}\\; e^{-\\I k y}\\psi(y) \\Bigr)\\\\\n  = \\int\\frac{\\d{k}}{(2\\pi)}\\d{y}\\; \\frac{e^{\\I k (x-y)}\\hbar^2k^2}{2m} \\psi(y).\n$$\n\n$$\n  \\FFT[\\psi(x)] = \\int\\d{x}\\; e^{-\\I k x}\\psi(x) = \\frac{L}{N}\\sum_{n} e^{-\\I k x_n}\\psi(x_n),\\\\\n  \\FFT^{-1}(\\psi_k) = \\int\\frac{\\d{k}}{(2\\pi)}\\; e^{\\I k x}\\psi_k = \\frac{1}{L}\\sum_{m} e^{\\I k_m x}\\psi_{k_m}.\n$$\n\nWhen doing both the FFT and the IFFT, the factors of $L$ cancel and we are left with an overall factor of $1/N$.  This can be split into two factors of $1/\\sqrt{N}$:\n\n$$\n  \\FFT^{-1}\\Bigl(f(k)\\FFT(\\psi)\\Bigr) = \\mat{U}^{-1}\\cdot \\diag(f_k) \\cdot \\mat{U} \\cdot \\psi\n  = \\sum_{xy}(U_{xk}^* f_k U_{ky}\\psi_y).\n$$\n\nThus, the kinetic energy matrix is:\n\n$$\n  \\mat{K}_{xy} = \\frac{1}{N}\\frac{e^{\\I k (x-y)}\\hbar^2k^2}{2m}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"17195c","pos":8,"input":"Another solution to this problem has a nice formulation in terms of an energy density functional $E[\\mat{R}]$ as a function of the full density matrix $\\mat{R}$ which we may express in terms of the minimization problem:\n\n$$\n  \\min_\\mat{R} \\Bigl\\{\n    E(\\mat{R}) + T \\Tr \\bigl[\\mat{R}\\ln \\mat{R}  + (\\mat{1} - \\mat{R})\\ln(\\mat{1}-\\mat{R})\\bigr]\n    \\Bigr\\}, \\qquad\n    \\Tr \\mat{R} = 1, \\qquad\n    \\mat{R} = \\mat{R}^\\dagger.\n$$\n\nThe solution is\n\n$$\n  \\mat{R} = f_\\beta(\\mat{H}) = \\frac{1}{1+e^{\\beta \\mat{H}}}, \\qquad\n  \\beta = \\frac{1}{k_B T}, \\qquad\n  \\mat{H} = \\frac{\\delta E[\\mat{R}]}{\\delta \\mat{R}^T}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"174952","pos":91,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=1, v0=2.5)\n#q1 = np.array((np.ones(l.N),)*3)\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        q1 = l.iterate(q1, plot=False)","cell_type":"code","exec_count":0}
{"type":"cell","id":"1832e2","pos":21,"input":"gaudin(1.0)","output":{"0":{"data":{"text/plain":"(0.3855702104019485, 1.1362343507927228)"},"output_type":"execute_result","exec_count":5}},"cell_type":"code","exec_count":5}
{"type":"cell","id":"1aa5f8","pos":80,"input":"%pylab inline --no-import-all\nfrom IPython.display import display, clear_output\nimport bcs;reload(bcs)\nimport homogeneous;reload(homogeneous)\nfrom bcs import BCS\n\nclass Lattice(BCS):\n    \"\"\"Adds optical lattice potential to species a with depth V0.\"\"\"\n    cells = 1.0\n    t = 0.0007018621290128983\n    E0 = -0.312433127299677\n    power = 4\n    V0 = -10.5\n\n    def __init__(self, cells=1, N=2**5, L=10.0, \n                 mu_a=1.0, mu_b=1.0, v0=0.1,\n                 V0=-10.5, power=2,\n                 **kw):\n        self.power = power\n        self.mu_a = mu_a\n        self.mu_b = mu_b\n        self.v0 = v0\n        self.V0 = V0\n        self.cells = cells\n        BCS.__init__(self, L=cells*L, N=cells*N, **kw)\n\n    def get_v_ext(self):\n        v_a = (-self.V0 * (1-((1+np.cos(2*np.pi * self.cells*self.x/self.L))/2)**self.power)\n               )\n        v_b = 0 * self.x\n        return v_a, v_b\n\n    def iterate(self, mudelta, N_twist=1, plot=False, **kw):\n        mu_a, mu_b, delta = nudelta\n        if np.isinf(N_twist):\n            R = self.get_R_twist_average(mus=(mu_a, mu_b), delta=delta, **kw)\n        else:\n            R = self.get_R(mus=(mu_a, mu_b), delta=delta, N_twist=N_twist)\n        na = np.diag(R)[:l.N]/l.dx\n        nb = (1 - np.diag(R)[l.N:])/l.dx\n        kappa = np.diag(R[:l.N, l.N:])/l.dx\n        mu_a = self.mu_a + self.v0*nb\n        mu_b = self.mu_b + self.v0*na\n        delta = self.v0*kappa\n        if plot:\n            plt.clf()\n            plt.plot(self.x, na)\n            plt.plot(self.x, nb)\n            plt.plot(self.x, delta)\n            display(plt.gcf())\n            print(delta.real.max(), na.real.max(), nb.real.max())\n        else:\n            display(\"{:.12f}, {:.12f}, {:.12f}\".format(delta.real.max(), na.real.max(), nb.real.max()))\n        clear_output(wait=True)\n        return np.array((mu_a, mu_b, delta))\n\n    def iterate_full(self, mudelta, \n                     na_avg=0.5, nb_avg=0.5, \n                     N_twist=1, plot=False, **kw):\n        mu_a, mu_b, mu_a_eff, mu_b_eff, delta = mudelta\n        mus = (mu_a_eff, mu_b_eff)\n        if np.isinf(N_twist):\n            R = self.get_R_twist_average(mus=mus, delta=delta, **kw)\n        else:\n            R = self.get_R(mus=mus, delta=delta, N_twist=N_twist)\n        na = np.diag(R)[:l.N]/l.dx\n        nb = (1 - np.diag(R)[l.N:])/l.dx\n\n        mu_a = mu_a*(1 + (na_avg - na.mean()))\n        mu_b = mu_b*(1 + (nb_avg - nb.mean()))\n\n        kappa = np.diag(R[:l.N, l.N:])/l.dx\n        mu_a_eff = mu_a + self.v0*nb\n        mu_b_eff = mu_b + self.v0*na\n        delta = self.v0*kappa\n        if plot:\n            plt.clf()\n            plt.plot(self.x, na)\n            plt.plot(self.x, nb)\n            plt.plot(self.x, delta)\n            display(plt.gcf())\n            print(delta.real.max(), na.real.mean(), nb.real.mean())\n        else:\n            display(\"{:.12f}, {:.12f}, {:.12f}\".format(\n                delta.real.max(), na.real.mean(), nb.real.mean()))\n            #display(\"{:.12f}, {:.12f}, {:.12f}, {:.12f}, {:.12f}\".format(\n            #    mu_a, mu_b, delta.real.max(), na.real.mean(), nb.real.mean()))\n        clear_output(wait=True)\n        return (mu_a, mu_b, mu_a_eff, mu_b_eff, delta)","output":{"0":{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n"}},"cell_type":"code","exec_count":15}
{"type":"cell","id":"1fab84","pos":28,"input":"Then\n$$\n  \\omega_{\\pm} = \\epsilon^{-}_k \\pm E_k, \\qquad\n  E_k = \\sqrt{(\\epsilon^{+}_k)^2 + \\Delta^2}, \\qquad\n  \\epsilon^{\\pm}_{k} = \\frac{\\epsilon^\\uparrow_k \\pm \\epsilon^\\downarrow_{-k}}{2},\\\\\n  \\epsilon^{\\uparrow}_k = K^{\\uparrow}_{k} - v_0n^{\\downarrow} - \\mu^{\\uparrow} \n                      = K^{\\uparrow}_{k} - \\mu^{\\uparrow}_{\\text{eff}},\\\\\n  \\epsilon^{\\downarrow}_{-k} = K^{\\downarrow}_{-k} - v_0n^{\\uparrow} - \\mu^{\\downarrow} \n                      = K^{\\downarrow}_{-k} - \\mu^{\\downarrow}_{\\text{eff}},\\\\\n  \\abs{u^{\\pm}_k}^2 = \\frac{1\\pm\\epsilon^+_k/E_k}{2}, \\qquad\n  \\abs{v^{\\pm}_k}^2 = \\frac{1\\mp\\epsilon^+_k/E_k}{2},\n$$\n\n**if we may assume** \n$\n\\epsilon_k^{\\uparrow} =\\epsilon_{-k}^{\\downarrow}\n$, **then** $\\omega_- = -\\omega_+$\n\n **Let $n_+$ is the total particle number, while $n_-$ is the number difference**\n \n\\begin{align}\n  n_+ \n  &= n(\\epsilon_+)+n(\\epsilon_-)\\\\\n  &= \\int\\frac{\\d{k}}{2\\pi}\\left(\n    1 - \\frac{\\epsilon^+_k}{2E_k}\n    \\left[\\tanh(\\beta\\omega_+/2) - \\tanh(\\beta\\omega_-/2)\\right]\n  \\right)\\\\\n  &= \\int\\frac{\\d{k}}{2\\pi}\\left(\n    1 - \\frac{\\epsilon^+_k}{E_k}\n    \\bigl(f(\\omega_-) - f(\\omega_+)\\bigr)\\right),\\\\\n  n_- \n  &= n(\\epsilon_+)-n(\\epsilon_-)\\\\\n  &= \\int\\frac{\\d{k}}{2\\pi}\\left(\n      - \\frac{1}{2}\\left[\n    \\tanh(\\beta\\omega_+/2) + \\tanh(\\beta\\omega_-/2)\n  \\right]\\right)\\\\\n  &= \\int\\frac{\\d{k}}{2\\pi}\n  \\bigl(f(\\omega_+) - f(-\\omega_-)\\bigr),\\\\\n    \\Delta \n  &= \\frac{v_0}{2}\\int \\frac{\\d{k}}{2\\pi}\\frac{\\Delta}{E_k}\\frac{\\left[\\tanh(\\beta\\omega_+/2) - \\tanh(\\beta\\omega_-/2)\\right]}{2},\\\\\n  &= \\frac{v_0}{2}\\int \\frac{\\d{k}}{2\\pi}\\frac{\\Delta}{E_k}\\bigl(f(\\omega_-)-f(\\omega_+)\\bigr),\\\\\n  \\frac{1}{v_0} \n  &= \\frac{1}{2}\\int \\frac{\\d{k}}{2\\pi}\\frac{1}{E_k}\\bigl(f(\\omega_-)-f(\\omega_+)\\bigr).\n\\end{align}","cell_type":"markdown"}
{"type":"cell","id":"21f68e","pos":47,"input":"Estimating the IR errors is more difficult: they arise from the variations of the integrand over the range $\\d{k}$:","cell_type":"markdown"}
{"type":"cell","id":"262642","pos":51,"input":"For many-body wave function in periodic boundary conditions, one may assume the phase of the wavefunction returns to the same wavlue when a particle goes around the boundaries and returns to its original position. [Lin:2001] points out that such assumption may lead to a slow-down of converge for deloclized fermion systems, due to the shell efficts in the filling of single particle states. So to alleviate the shell effect, we allow the overall many-body wave funtions to pick up a phase when particles in the system wrap around the periodic boundaries:\n$$\n\\Psi(r_1+L\\hat{x},r_2,...)=e^{i\\theta_x}\\Psi(r_1,r_2...)\n$$\nGenerally, the $\\theta$ is restirced in the range:\n$$\n-\\pi<\\theta_x\\le\\pi\n$$\n\nThen the twist average of any oberserable is defined:\n$$\n\\braket{\\hat{A}}=(2\\pi)^{-d} \\int_{-\\pi}^{\\pi} d\\theta\\braket{\\psi(R,\\theta)|\\hat{A}|\\psi(R,\\theta)}\n$$\n\nNumerically, we will only sample some values of $\\theta$ and avaerage over the results, such method may be well enough. One can also randomly displace the origin of the grid for a number of time during compuation..","cell_type":"markdown"}
{"type":"cell","id":"267a37","pos":5,"input":"## <font color='green'>The Variational Mean-field Method</font>","cell_type":"markdown"}
{"type":"cell","id":"2bf0ca","pos":108,"input":"# Python Environment","cell_type":"markdown"}
{"type":"cell","id":"2c5299","pos":66,"input":"For a given scattering length $a$, we got an effective $g_e$,so:\n$$\n\\frac{1}{g_e}= \\frac{m}{4\\pi\\hbar^2a}-\\frac{mk_c}{2\\hbar^2\\pi^2}\n$$","cell_type":"markdown"}
{"type":"cell","id":"2ddf89","pos":34,"input":"We now present the solution for inhomogeneous states.\n\n$$\n  \\epsilon_k^{\\uparrow} = \\frac{k_\\perp^2}{2m} + 2t[1-\\cos(k_z d)] - \\mu_\\uparrow, \\qquad\n  \\epsilon_k^{\\downarrow} = \\frac{k^2}{2m} - \\mu_\\downarrow.\n$$\n\nThe dispersion relationship here is a bit of a misnomer.  There low-energy states are just the single Bloch band $\\abs{k_z} \\leq \\pi/d$.  The other bands are much higher separated by a large gap.\n\nThe BdG equations follow from the single-particle Hamiltonian (assuming homogeneous states)\n\n$$\n  \\begin{pmatrix}\n    \\epsilon_k^{\\uparrow} & \\Delta\\\\\n    \\Delta & -\\epsilon_k^{\\downarrow}\n  \\end{pmatrix}\n$$\n\nwhich has eigenvectors and eigenvalues\n\n$$\n  \\omega_{\\pm} = \\epsilon^{-}_k \\pm E_k, \\qquad\n  E_k = \\sqrt{(\\epsilon^{+}_k)^2 + \\Delta^2}, \\\\\n  \\epsilon^{\\pm}_{k} = \\frac{\\epsilon^\\uparrow_k \\pm \\epsilon^\\downarrow_k}{2}\\\\\n  \\abs{u^{\\pm}_k}^2 = \\frac{1\\pm\\epsilon^+_k/E_k}{2}, \\qquad\n  \\abs{v^{\\pm}_k}^2 = \\frac{1\\mp\\epsilon^+_k/E_k}{2},\\\\\n  n_+ = 1 - \\frac{\\epsilon^+_k}{2E_k}\\left[\\tanh(\\beta\\omega_+/2) - \\tanh(\\beta\\omega_-/2)\\right], \\qquad\n  n_- = - \\frac{1}{2}\\left[\\tanh(\\beta\\omega_+/2) + \\tanh(\\beta\\omega_-/2)\\right]\\\\\n  \\Delta = -g\\int \\frac{\\d^{3}\\vect{k}}{(2\\pi)^3}\\frac{\\Delta}{2E_k}\\frac{\\left[\\tanh(\\beta\\omega_+/2) - \\tanh(\\beta\\omega_-/2)\\right]}{2}\n$$","cell_type":"markdown"}
{"type":"cell","id":"2f172f","pos":55,"input":"Suppose we want a tolerance of $\\delta \\ln \\Delta < 10^{-4}$, then we must have $L/N < 4.5$.  Computationally, we can conveniently work with $N=2^{10} = 1024$, so $L < 0.46$.","cell_type":"markdown"}
{"type":"cell","id":"318212","pos":100,"input":"cells = 20\nprint(p)\n#V = V0*sum(np.exp(-(x-n*L/cells)**2/2/r0**2) for n in range(-cells, cells))\n","cell_type":"code","exec_count":0}
{"type":"cell","id":"323ca5","pos":4,"input":"# HFB Theory (BCS Superconductivity)","cell_type":"markdown"}
{"type":"cell","id":"347a15","pos":43,"input":"Or expanded as a row vector times a column vector:\n$$\nU = e^{-i\\begin{pmatrix}\n   k_1\\\\k_2\\\\\\vdots\\\\k_N\\\\\n  \\end{pmatrix}\\times  \n  \\begin{pmatrix}\n   x_1&x_2&...&x_N\\\\\n  \\end{pmatrix}\n  }\n$$","cell_type":"markdown"}
{"type":"cell","id":"372266","pos":88,"input":"For the paper I am reviewing, the choose parameters as follows:\n\n$$\n  k_FL = 50, \\qquad\n  t/E_F = 0.1, \\qquad\n  \\mu/E_F = 9.5.\n$$","cell_type":"markdown"}
{"type":"cell","id":"3760be","pos":75,"input":"Here we present the band structure calculation for a periodic square well potential with period $L$ and barrier $V_0$ extending from $x=0$ to $x=a$.  To find the band structure, we use [Bloch's theorem](https://en.wikipedia.org/wiki/Bloch_wave) that the solution can be expressed as:\n\n$$\n  \\psi(x) = e^{\\I k_B x} u(x), \\qquad u(x+L) = u(x).\n$$\n\nTo formulate the solution, we work with the transfer matrix approach.  At any point $x$ in space, we decompose the wavefunction $u(x) = u_-(x) + u_+(x)$ into a left-moving piece $u_-(x)$ and a right-moving piece $u_+(x)$:\n\n$$\n  \\vect{U}(x) = \\begin{pmatrix}\n    u_+(x)\\\\\n    u_-(x)\n  \\end{pmatrix}.\n$$\n\nWe then define the transfer matrix $\\mat{T}(x, x')$ such that\n\n$$\n  \\vect{U}(x) = \\mat{T}(x, x')\\cdot\\vect{U}(x').\n$$\n\nThe transfer matrix over a region where the potential is constant $V(x) = V_0$ is:\n\n$$\n  \\mat{T}(x,x') = \\begin{pmatrix}\n    e^{\\I k_0 (x-x')}\\\\\n    0 & e^{-\\I k_0 (x-x')}\n  \\end{pmatrix}, \\qquad\n  \\frac{\\hbar^2 k_0^2}{2m} = E - V_0.\n$$\n\nA little more complicated is the transfer matrix from a region with $k=k$ to a region with $k=k_0$.  Across this jump we must make sure the wavefunction is $C^1$ continuous, thus we have:\n\n$$\n  u_+(-\\epsilon) + u_-(-\\epsilon) = u_+(\\epsilon) + u_-(\\epsilon), \\qquad\n  \\I k u_+(-\\epsilon) - \\I k u_-(-\\epsilon) = \\I k_0 u_+(\\epsilon) - \\I k_0 u_-(\\epsilon).\n$$\n\n$$\n  u_+(-\\epsilon) + u_-(-\\epsilon) = u_+(\\epsilon) + u_-(\\epsilon), \\qquad\n  \\I k u_+(-\\epsilon) - \\I k u_-(-\\epsilon) = \\I k_0 u_+(\\epsilon) - \\I k_0 u_-(\\epsilon),\\\\\n  \\vect{U}(\\epsilon) = \\frac{1}{2}\n  \\begin{pmatrix}\n    \\overbrace{1+\\frac{k}{k_0}}^{\\alpha^{+}_{k/k_0}} & \\overbrace{1-\\frac{k}{k_0}}^{\\alpha^{-}_{k/k_0}}\\\\\n    1-\\frac{k}{k_0} & 1+\\frac{k}{k_0}\n  \\end{pmatrix}\\cdot\\vect{U}(-\\epsilon).\n$$\n\nLikewise, for a transition from a region with $k=k_0$ to a region with $k=k$ we have:\n\n$$\n  \\vect{U}(\\epsilon) = \\frac{1}{2}\n  \\begin{pmatrix}\n    \\overbrace{1+\\frac{k_0}{k}}^{\\alpha^{+}_{k_0/k}} & \\overbrace{1-\\frac{k_0}{k}}^{\\alpha^{-}_{k_0/k}}\\\\\n    1-\\frac{k_0}{k} & 1+\\frac{k_0}{k}\n  \\end{pmatrix}\\cdot\\vect{U}(-\\epsilon).\n$$\n\nThis can be simplified by noting that:\n\n$$\n  \\alpha^{\\pm}_{k_0/k} = \\pm\\frac{k_0}{k}\\overbrace{\\alpha^{\\pm}_{k/k_0}}^{\\alpha_{\\pm}}.\n$$\n\nThus, the full transfer matrix for our potential from $x=0$ to $x=L$ is:\n\n$$\n  \\mat{T} = \\frac{1}{4}\\frac{k_0}{k}\n  \\begin{pmatrix}\n    e^{\\I k (L-a)}\\\\\n    0 & e^{-\\I k (L-a)}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    \\alpha_{+} & - \\alpha_{-}\\\\\n    -\\alpha_{-} & \\alpha_{+}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    e^{\\I k_0 a}\\\\\n    0 & e^{-\\I k_0 a}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    \\alpha_{+} & \\alpha_{-}\\\\\n    \\alpha_{-} & \\alpha_{+}\n  \\end{pmatrix},\\\\\n  = \\frac{1}{4}\\frac{k_0}{k}\n  \\begin{pmatrix}\n    e^{\\I k (L-a)}\\\\\n    0 & e^{-\\I k (L-a)}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    e^{\\I k_0 a}\\alpha_{+}^2 - e^{-\\I k_0 a}\\alpha_{-}^2\n    & \\alpha_{+}\\alpha_{-}(e^{\\I k_0 a}-e^{-\\I k_0 a})\\\\\n    \\alpha_{+}\\alpha_{-}(-e^{\\I k_0 a}+e^{-\\I k_0 a})\n    & -e^{\\I k_0 a}\\alpha_{-}^2 + e^{-\\I k_0 a}\\alpha_{+}^2\n  \\end{pmatrix},\\\\\n  = \\frac{1}{4}\\frac{k_0}{k}\n  \\begin{pmatrix}\n    e^{\\I k (L-a)}\\\\\n    0 & e^{-\\I k (L-a)}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    \\overbrace{2\\I\\left(1+\\frac{k^2}{k_0^2}\\right)\\sin(k_0a) + 4\\frac{k}{k_0}\\cos(k_0 a)}^{A}\n    & \\overbrace{2\\I\\left(1-\\frac{k^2}{k_0^2}\\right)\\sin(k_0 a)}^{B}\\\\\n    -2\\I\\left(1-\\frac{k^2}{k_0^2}\\right)\\sin(k_0 a)\n    & -2\\I\\left(1+\\frac{k^2}{k_0^2}\\right)\\sin(k_0a) + 4\\frac{k}{k_0}\\cos(k_0 a)\n  \\end{pmatrix},\\\\\n  = \\frac{1}{4}\\frac{k_0}{k}\n  \\begin{pmatrix}\n    e^{\\I k (L-a)}\\\\\n    0 & e^{-\\I k (L-a)}\n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    A & B\\\\\n    B^* & A^*\n  \\end{pmatrix}.  \n$$","cell_type":"markdown"}
{"type":"cell","id":"39f54b","pos":15,"input":"## <font color='green'>Inhomogeneous Systems</font>","cell_type":"markdown"}
{"type":"cell","id":"3e56a1","pos":54,"input":"This plot shows that our estimates of the UV errors is accurate, that the UV errors in $\\Delta$ dominate, and that $L\\approx 25$ is required for reasonable IR convergence.  The following plot shows that the IR errors are quite complicated in structure (shell effects).  Fortunately, we can reduce these errors by explicitly performing the **Bloch (twist) averaging**  (see examples [Lin:2001] ,[Kolorenc:2011]) as we shall describe below.\n\n\n[Lin:2001]: https://arxiv.org/pdf/cond-mat/0101339.pdf 'Twist-averaged Boundary Conditions in Continuum Quantum Monte Carlo'\n\n[Kolorenc:2011]: http://www.giovannibachelet.it/MitasRPP2011a.pdf 'Applications of quantum Monte Carlo methods in condensed systems'","cell_type":"markdown"}
{"type":"cell","id":"3e98be","pos":78,"input":"The Lattice potential admits an exact solution in terms of Mathier fuctions and the single-band model is appropriate when $h>2$:\n\n$$\n  \\frac{\\op{p}^2}{2m} + \\frac{V_0}{2}\\cos(2k_0x),\n  \\qquad\n  L = \\frac{\\pi}{k_0}, \\qquad\n  E_R = \\frac{\\hbar^2 k_0^2}{2m}, \\qquad\n  4h^2 = \\frac{V_0}{E_R}, \\qquad\n  \\lambda = \\frac{E}{E_R},\\\\\n  E(k) = E_0 + 2t\\cos(kL) +\\cdots, \\qquad\n  \\frac{t}{E_R} = \\frac{8\\sqrt{2}}{\\sqrt{\\pi}}h^{3/2}e^{-4h}\\left[1+\\order(1/h)\\right]\n$$\n\nhttp://iopscience.iop.org/article/10.1088/1361-6404/aa8d2c/meta","cell_type":"markdown"}
{"type":"cell","id":"4593dd","pos":42,"input":"Now I convince myself that the kinetic matrix can be put as:\n\\begin{align}\nT&=U^\\dagger\\times diag[f(k)]\\times U\\\\\nU&=\\frac{1}{\\sqrt{N}}e^{-kx}\\\\\nU&=\\frac{1}{\\sqrt{N}}\n\\begin{pmatrix}\n    e^{-ik_1x_1} & e^{-ik_1x_2}&...&e^{-ik_1x_N}\\\\\n    e^{-ik_2x_1} & e^{-ik_2x_2}&...&e^{-ik_2x_N}\\\\\n    \\vdots\\\\\n    e^{-ik_Nx_1} & e^{-ik_Nx_2}&...&e^{-ik_Nx_N}\\\\\n  \\end{pmatrix}\n\\end{align}","cell_type":"markdown"}
{"type":"cell","id":"47c49d","pos":33,"input":"## <font color='orange'>Inhomogeneous States</font>","cell_type":"markdown"}
{"type":"cell","id":"4f27da","pos":10,"input":"We start with standard BCS theory, which is the HFB approximation to the following family of Hamiltonions:\n\n$$\n  \\op{H} = \\sum_{k} \\left(\n    E^{a}_{k}\\op{a}_{k}^\\dagger\\op{a}_{k}\n    +\n    E^{b}_{k}\\op{b}_{k}^\\dagger\\op{b}_{k}\n  \\right)\n  +\n  \\int\\d{x}\\d{y}\\; V(x-y)\\op{n}_{a}(x)\\op{n}_{b}(y).\n$$\n\nThis describes two species of particle ($a$, and $b$) interacting with a potential $V(x-y)$.\n\nWe first applying the Feynman variational principle, considering a trial Hamiltonian of the form:\n\n$$\n  \\op{H}_0 = \\sum_{k>0} \n  \\begin{pmatrix}\n    \\op{a}_{k}^\\dagger &\n    \\op{b}_{-k}\\\\    \n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    E^{a}_{k} - \\Sigma^a_k & \\Delta_k\\\\\n    \\Delta^*_{k} & -E^{b}_{-k} + \\Sigma^b_{-k}   \n  \\end{pmatrix}\n  \\cdot\n  \\begin{pmatrix}\n    \\op{a}_{k}\\\\\n    \\op{b}_{-k}^\\dagger\n  \\end{pmatrix}.\n$$\n\nHere we will consider the self-energies $\\Sigma$ and pairing gap $\\Delta$ as variational parameters.","cell_type":"markdown"}
{"type":"cell","id":"507b1c","pos":48,"input":"$$\n  \\frac{1}{\\d{k}}\\int_{-\\d{k}/2}^{\\d{k}/2}\\d{k_b}\\left\\{\n    \\frac{\\d{k}}{2\\pi}\\sum_{n}f(k_n + k_b)\n  \\right\\} \n  \\approx\n  \\frac{1}{\\d{k}}\\int_{-\\d{k}/2}^{\\d{k}/2}\\d{k_b}\\left\\{\n    \\frac{\\d{k}}{2\\pi}\\sum_{n}\\left[f(k_n) + k_bf'(k_n) + \\frac{k_b^2}{2}f''(k_n)\\right]\n  \\right\\}\\\\\n  =\n    \\frac{\\d{k}}{2\\pi}\\sum_{n}\n    \\left\\{\n      f(k_n)\n      +\n      \\frac{\\d{k}^2}{24}f''(k_n)\n  \\right\\}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"50a3e3","pos":14,"input":"For homogeneous matter, momentum $p = \\hbar k$ is a good quantum number, and so we can label all eigenstates of the system with the wavenumber $k$.  To describe two component superfluids, we introduce the quadratic Hamiltonian\n\n$$\n  \\op{H}_0(k) = \\op{\\Psi}^\\dagger_{k} \\cdot \\mat{H}_{k} \\cdot \\op{\\Psi}_{k}\n$$\n\nwhere $\\op{\\Psi}_k = (\\op{a}_{k}, \\op{b}_{-k}^\\dagger)$ and \n\n$$\n  \\mat{H}_{k} = \\begin{pmatrix}\n    A & \\Delta \\\\\n    \\Delta^\\dagger & -B\n  \\end{pmatrix}\n$$\n\nwith $A$ and $B$ are the dispersion relationships for the two particles:\n\n$$\n  A = \\frac{\\hbar^2k^2}{2m_A} - \\mu_A.\n$$\n\nThis quadratic Hamiltonian can be \"solved\" by diagonalizing the matrix with a unitary matrix $\\mat{U}$:\n\n$$\n  \\mat{U}^\\dagger\\mat{H}\\mat{U} = \\diag(E_-, E_+).\n$$\n\nOnce this is done, we end up with a diagonal Hamiltonian\n\n$$\n  \\op{H}_0 = \\op{C}^\\dagger \\begin{pmatrix}\n    E_-\\\\\n    & E_+\n  \\end{pmatrix}\n  \\op{C}\n  = E_- \\op{c}_-^\\dagger\\op{c}_- + E_+ \\op{c}_+^\\dagger\\op{c}_+\n$$\n\nwhere $\\op{c}_{\\pm}$ are the creation operators for fermionic \"quasiparticles\", which are linear combinations of the original particles $\\op{a}$ and $\\op{b}^\\dagger$.  Since the Hamiltonian is now diagonal, the thermal ensemble can be simply presented in terms of the Fermi distribution and inverse temperature $\\beta = 1/k_BT$:\n\n$$\n  f_{\\beta}(E) = \\frac{1}{1+e^{\\beta E}}.\n$$\n\nNote: The energy $E$ here will contain the chemical potential $E-\\mu$.","cell_type":"markdown"}
{"type":"cell","id":"519f00","pos":39,"input":"Even all the above looks right to me, to get the code level, I have to struggle a lot to fully appreciate how it works.\nTo better understand the way how the kenectic matrix is presented, let dig a bit more to the detail of how linear aglbra works here, let say the kenitic operator is $\\vec{T})$, from above derivation, we got:\n\n$$\n\\vec{T}\\psi(x)=\\frac{1}{N}\\sum_{ky}{e^{ikx-iky}f(k)}\\psi(y)\n$$\n\nthe varibles $x$ and $k$ are spatial and wave-vector points. Pick one specific spatial position $x_1$, then\n\n\\begin{align}\n\\vec{T}\\psi(x)|_{x=x1}\n&=\\frac{1}{N}\\sum_{ky}{e^{ikx_1-iky}f(k)}\\phi(y)\\\\\n&=\\frac{1}{N}\\sum_{k}{e^{ikx_1}f(k)}\\left[e^{-iky_1}\\psi(y_1)+e^{-iky_2}\\psi(y_2)+...+ e^{-iky_N}\\psi(y_N)\\right]\n\\end{align}\n\nfor different values of $x={x_1,x_2,...x_N}$, we have:\n\\begin{align}\n\\vec{T}\\psi(x)|_{x=x_1}=\\frac{1}{N}\\sum_{k}{e^{ikx_1}f(k)}\\left[e^{-iky_1}\\psi(y_1)+e^{-iky_2}\\psi(y_2)+...+ e^{-iky_N}\\psi(y_N)\\right]\\\\\n\\vec{T}\\psi(x)|_{x=x_2}=\\frac{1}{N}\\sum_{k}{e^{ikx_2}f(k)}\\left[e^{-iky_1}\\psi(y_1)+e^{-iky_2}\\psi(y_2)+...+ e^{-iky_N}\\psi(y_N)\\right]\\\\\n\\vdots\\\\\n\\vec{T}\\psi(x)|_{x=x_N}=\\frac{1}{N}\\sum_{k}{e^{ikx_N}f(k)}\\left[e^{-iky_1}\\psi(y_1)+e^{-iky_2}\\psi(y_2)+...+ e^{-iky_N}\\psi(y_N)\\right]\\\\\n\\end{align}\nThe above result is can be put as a matrix times a column vector:","cell_type":"markdown"}
{"type":"cell","id":"53f1a1","pos":97,"input":"cells = 10\nL_cell = 10.0\nN = 2*64*cells\nL = L_cell*cells\n\nr0 = 2.0\np = np.ceil(L**2/2/r0**2/cells**2/np.pi**2/2)*2\nV0 = -0.5\ndx = L/N\nx = np.arange(N)*dx - L/2\nk = 2*np.pi * np.fft.fftfreq(N, dx)\nk_bloch = 2*np.pi * np.fft.fftfreq(cells, L_cell)\nV = V0 *(((1+np.cos(2*np.pi*cells*x/L))/2)**p)\n\nQ = np.exp(1j*k[:,None]*x[None,:])\nK = Q.T.conj().dot(k[:,None]**2/2 * Q)/N\nH = K + np.diag(V)\nd, psi = np.linalg.eigh(H)\nplt.plot(x, psi[:,0])\nplt.twinx()\nplt.plot(x, V, 'r:')\nplt.figure()\n\nplt.plot(d[:cells])","cell_type":"code","exec_count":0}
{"type":"cell","id":"54179c","pos":11,"input":"## <font color='green'>Diagonalization</font>","cell_type":"markdown"}
{"type":"cell","id":"55fac0","pos":3,"input":"try:\n    reload  # Python 2.7\nexcept NameError:\n    try:\n        from importlib import reload  # Python 3.4+\n    except ImportError:\n        from imp import reload  # Python 3.0 - 3.3","cell_type":"code","exec_count":3,"metadata":{"init_cell":true}}
{"type":"cell","id":"56b18f","pos":1,"input":"import mmf_setup;mmf_setup.nbinit(hgroot=False)\nfrom mmfutils.contexts import NoInterrupt","output":{"0":{"data":{"text/html":"<style>.grade {\n   background-color: #66FFCC;\n}\n</style>"},"output_type":"execute_result","exec_count":2},"1":{"data":{"application/javascript":""},"output_type":"execute_result","exec_count":2},"2":{"data":{"text/html":"<script id=\"MathJax-Element-48\" type=\"math/tex\">\\newcommand{\\vect}[1]{\\mathbf{#1}}\n\\newcommand{\\uvect}[1]{\\hat{#1}}\n\\newcommand{\\abs}[1]{\\lvert#1\\rvert}\n\\newcommand{\\norm}[1]{\\lVert#1\\rVert}\n\\newcommand{\\I}{\\mathrm{i}}\n\\newcommand{\\ket}[1]{\\left|#1\\right\\rangle}\n\\newcommand{\\bra}[1]{\\left\\langle#1\\right|}\n\\newcommand{\\braket}[1]{\\langle#1\\rangle}\n\\newcommand{\\Braket}[1]{\\left\\langle#1\\right\\rangle}\n\\newcommand{\\op}[1]{\\mathbf{#1}}\n\\newcommand{\\mat}[1]{\\mathbf{#1}}\n\\newcommand{\\d}{\\mathrm{d}}\n\\newcommand{\\pdiff}[3][]{\\frac{\\partial^{#1} #2}{\\partial {#3}^{#1}}}\n\\newcommand{\\diff}[3][]{\\frac{\\d^{#1} #2}{\\d {#3}^{#1}}}\n\\newcommand{\\ddiff}[3][]{\\frac{\\delta^{#1} #2}{\\delta {#3}^{#1}}}\n\\newcommand{\\floor}[1]{\\left\\lfloor#1\\right\\rfloor}\n\\newcommand{\\ceil}[1]{\\left\\lceil#1\\right\\rceil}\n\\DeclareMathOperator{\\Tr}{Tr}\n\\DeclareMathOperator{\\erf}{erf}\n\\DeclareMathOperator{\\erfi}{erfi}\n\\DeclareMathOperator{\\sech}{sech}\n\\DeclareMathOperator{\\sgn}{sgn}\n\\DeclareMathOperator{\\order}{O}\n\\DeclareMathOperator{\\diag}{diag}\n\n\\newcommand{\\mylabel}[1]{\\label{#1}\\tag{#1}}\n\\newcommand{\\degree}{\\circ}</script>"},"output_type":"execute_result","exec_count":2},"3":{"data":{"text/html":""},"output_type":"execute_result","exec_count":2},"4":{"data":{"text/html":"\n<i>\n<p>This cell contains some definitions for equations and some CSS for styling\n  the notebook. If things look a bit strange, please try the following:\n<ul>\n  <li>Choose \"Trust Notebook\" from the \"File\" menu.</li>\n  <li>Re-execute this cell.</li>\n  <li>Reload the notebook.</li>\n</ul>\n</p>\n</i>\n"},"output_type":"execute_result","exec_count":2}},"cell_type":"code","exec_count":2,"metadata":{"init_cell":true}}
{"type":"cell","id":"587646","pos":32,"input":"import homogeneous;reload(homogeneous)\nfrom homogeneous import get_BCS_v_n_e, Homogeneous1D\n\nres0 = get_BCS_v_n_e(mu_eff=1.2, delta=3.4)\n\nh = Homogeneous1D(T=10.0)\nres1 = h.get_BCS_v_n_e(mus_eff=(1.2,)*2, delta=3.4)\n(res0, res1)","output":{"0":{"name":"stderr","output_type":"stream","text":"/usr/local/lib/python3.6/dist-packages/scipy/integrate/quadpack.py:385: IntegrationWarning: The algorithm does not converge.  Roundoff error is detected\n  in the extrapolation table.  It is assumed that the requested tolerance\n  cannot be achieved, and that the returned result (if full_output = 1) is \n  the best which can be obtained.\n  warnings.warn(msg, IntegrationWarning)\n/home/user/repositories/quantum-turbulence/homogeneous.py:136: RuntimeWarning: overflow encountered in exp\n  return 1./(1+np.exp(E/self.T))\n"},"1":{"data":{"text/plain":"(BCS_Results(v_0=4.15862415484364, n=0.9994111444130727, mu=-0.8780876628880645, e=-1.5652560299212273),\n BCS_Results(v_0=10.3575534373504, ns=array([0.82712125, 0.82712125]), mus=array([-7.36695259, -7.36695259])))"},"output_type":"execute_result","exec_count":7}},"cell_type":"code","exec_count":7}
{"type":"cell","id":"5a640d","pos":79,"input":"The paper I am reviewing has $d\\equiv L$ $t/E_F = 0.1$ and $dk_F = 20-50$.  In terms of these parameters we have:\n\n$$\n  \\frac{t}{E_R} = \\frac{t}{E_F}\\left(\\frac{k_F}{k_0}\\right)^2 \n  = \\frac{t}{E_F}\\left(\\frac{d k_F}{\\pi}\\right)^2\n  = \\frac{2mt d^2}{\\pi^2} < 0.1, \\qquad\n  t d^2 < \\frac{1}{2m},\\\\\n  \\frac{t}{E_F}\\left(d k_F\\right)^2 < 1\n$$","cell_type":"markdown"}
{"type":"cell","id":"5ee48b","pos":76,"input":"# <font color='green'>Optical Lattice</font>","cell_type":"markdown"}
{"type":"cell","id":"5efacb","pos":17,"input":"# Homogeneous Matter","cell_type":"markdown"}
{"type":"cell","id":"5f94a8","pos":31,"input":"In 3D case, all integration should be done in 3 dimensions. $d^3k$ is the volumn. If the $k_z$ in the $z$ direction is different from other tow dimensions($k_\\perp$ ), we pick the cylindrical coordinate: $d^3k$ = $2{\\pi}k_{\\perp}d{k_z}dk_\\perp $(where the integration over $d\\theta$ is carried out and equal to $2\\pi$), \n\\begin{align}\n  n_+ \n  &= n(\\epsilon_+)+n(\\epsilon_-)\\\\\n  &= \\int\\frac{\\d^3{k}}{8{\\pi}^3}\\left(\n    1 - \\frac{\\epsilon^+_k}{2E_k}\n    \\left[\\tanh(\\beta\\omega_+/2) - \\tanh(\\beta\\omega_-/2)\\right]\n  \\right)\\\\\n  &= \\int\\frac{k_{\\perp}d{k_z}dk_{\\perp}}{4{\\pi}^2}\\left(\n    1 - \\frac{\\epsilon^+_k}{E_k}\n    \\bigl(f(\\omega_-) - f(\\omega_+)\\bigr)\\right),\\\\\n  n_- \n  &= n(\\epsilon_+)-n(\\epsilon_-)\\\\\n  &= \\int\\frac{k_{\\perp}d{k_z}dk_{\\perp}}{4{\\pi}^2}\\left(\n      - \\frac{1}{2}\\left[\n    \\tanh(\\beta\\omega_+/2) + \\tanh(\\beta\\omega_-/2)\n  \\right]\\right)\\\\\n  &= \\int\\frac{k_{\\perp}d{k_z}dk_{\\perp}}{4{\\pi}^2}\n  \\bigl(f(\\omega_+) - f(-\\omega_-)\\bigr),\\\\\n  \\frac{1}{v_0} \n  &=\\frac{m}{4\\pi a}-\\sum_{k}{{\\frac{1}{2\\epsilon^+_k}}}\\\\\n  &=\\sum_{k}{\\left[\\frac{1}{2\\epsilon^+_k}-\\frac{1-2\\bar{f}(E_k)}{2E_k}\\right]}-\\sum_{k}{{\\frac{1}{2\\epsilon^+_k}}}\\\\\n  &=\\sum_{k}{\\left[-\\frac{1-2\\bar{f}(E_k)}{2E_k}\\right]}\\\\\n  &=-\\int\\frac{k_{\\perp}d{k_z}dk_{\\perp}}{4{\\pi}^2}{\\left[\\frac{1-f(E_k + \\epsilon_+) + f(E_k - \\epsilon_-)}{2E_k}\\right]}\\\\\n\\end{align}","cell_type":"markdown"}
{"type":"cell","id":"644354","pos":68,"input":"Here we got a factor of 2 for $\\frac{1}{a}$ in contrast to the result from  Braaten and Hammer (2006), when compared the one used in the paper we reviewed, they also use the one has a factor of 2, so we will stick to this relation instead of  Braaten and Hammer (2006).","cell_type":"markdown"}
{"type":"cell","id":"645732","pos":53,"input":"Ns = 2**np.arange(5, 9)\nLs = [1.0, 10.0, 30.0]\nN_twists = [1, 2, 4]\nplt.figure(figsize=(5*len(N_twists), 5))\nfor _n, N_twist in enumerate(N_twists):\n    res_NL, res_UV = get_errs(Ns=Ns, Ls=Ls, N_twist=N_twist)\n    n_, d_ = np.array(res_NL).T\n    plt.subplot(101 + len(N_twists)*10 + _n)\n    for _i, L in enumerate(Ls):\n        _l, = plt.loglog(Ns, abs(n_[:, _i]-n)/n, '--+', label='$n({})$'.format(L), alpha=0.5)\n        plt.loglog(Ns, abs(d_[:, _i]-delta)/delta, '--o', c=_l.get_c(),\n                   label=r'$\\Delta({})$'.format(L), alpha=0.5)\n        plt.loglog(Ns, abs(res_UV[_i, :, 0])/n, ':', c=_l.get_c())\n        plt.loglog(Ns, abs(res_UV[_i, :, 1])/delta, ':', c=_l.get_c())\n    plt.ylabel('Rel err')\n    plt.xlabel('N')\n    plt.legend()\n    plt.title(\"N_twist={}\".format(N_twist))","output":{"0":{"data":{"image/png":"6a72dbba0a7dca006d299130d100ec9e90fce9fc"},"metadata":{"image/png":{"height":333,"width":897}},"output_type":"execute_result","exec_count":9}},"cell_type":"code","exec_count":9}
{"type":"cell","id":"6cde73","pos":96,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=1, v0=2.5)\n#q = np.array((np.ones(l.N),)*3)\n#q = qt24\nN_twist = np.inf\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        q = l.iterate(q, plot=False, N_twist=N_twist, abs_tol=1e-8)","cell_type":"code","exec_count":0}
{"type":"cell","id":"6dbd56","pos":111,"input":"!conda env update -f _environment.yml\n!rm _environment.yml","cell_type":"code","exec_count":0}
{"type":"cell","id":"6fb746","pos":62,"input":"As discussed above, the converges of the gap equation is quite poor in 1D.  In 3D the situation is even worse and the gap equation diverges.  To deal with this, some sort of regularization condition is needed.  There are two common stratgies:\n\n1. Fixed scattering length.  Here the approach is to replace the coupling constant $v_0$ with some physical observable such as the two-body scattering length.  The idea is to calculate the two-body scattering length $a_s$ using some convenient potential (with an appropriate regulator such as an energy cutoff $E_c$ or a lattice momentum cutoff $k_c$).  Then, adjust the coupling constant $v_0(E_c)$ as a function of this cutoff to hold the physical observable $a_s$ fixed.\n\n   $$\n   $$","cell_type":"markdown"}
{"type":"cell","id":"70bbe8","pos":69,"input":"# <font color='green'>Band Structure</font>","cell_type":"markdown"}
{"type":"cell","id":"72225e","pos":45,"input":"## <font color='orange'> Error Analysis</font>","cell_type":"markdown"}
{"type":"cell","id":"7261ce","pos":2,"input":"In order to work with Python 3+, we need to take care of those obsolete functions, the \\$reload$  is not a built function for Python 3","cell_type":"markdown"}
{"type":"cell","id":"796f30","pos":46,"input":"We start with the base BCS class which solves the problem in a 1D periodic universe.  This class will form the base for subsequent work, but is limited by the issue discussed above with discrete $k_n$.  As we shall see, there are two forms of errors: UV errors resulting from a limited $k_\\max = \\pi N/L$ and IR errors from the discrete $\\d{k} = \\pi/L$.  To estimate the UV errors, we consider the asymptotic form of the integrals:\n\n$$\n  \\delta_{UV}\\Delta = \\frac{v_0}{2}\\overbrace{2}^{\\pm k}\\int_{k_\\max}^{\\infty}\n    \\frac{\\d{k}}{2\\pi}\\;\\frac{\\Delta}{\\sqrt{\\epsilon_+^2 + \\Delta^2}} \n  \\approx v_0\\int_{k_\\max}^{\\infty} \\frac{\\d{k}}{2\\pi}\\;\\frac{2m\\Delta}{\\hbar^2k^2}\n  = \\frac{v_0m\\Delta}{\\pi\\hbar^2k_\\max} + \\frac{2v_0 m^2\\mu_\\mathrm{eff}}{3\\pi\\hbar^4k_\\max^3},\\\\\n  \\delta_{UV}n_+ = 2\\int_{k_\\max}^{\\infty}\\frac{\\d{k}}{2\\pi}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right]\n  \\approx \\int_{k_\\max}^{\\infty}\\frac{\\d{k}}{2\\pi}\n    \\frac{4m^2\\abs{\\Delta}^2}{\\hbar^4k^4}\n  = \\frac{2m^2\\abs{\\Delta}^2}{3\\pi\\hbar^4k_{\\max}^3} \n    + \\frac{8m^3\\mu_{\\mathrm{eff}}\\abs{\\Delta}^2}{5\\pi \\hbar^6 k_\\max^5}\n$$\n\nThe error in $\\Delta$ is largest, so we can set the lattice spacing to achieve the desired accuracy:\n\n$$\n  \\frac{L}{N} \\lesssim \\frac{\\pi^2\\hbar^2}{v_0 m}\\frac{\\delta_{UV}\\Delta}{\\Delta}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"7ca2ca","pos":92,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=4, v0=2.5, )\n#q4 = np.array((np.ones(l.N),)*3)\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        q4 = l.iterate(q4, plot=False)","cell_type":"code","exec_count":0}
{"type":"cell","id":"7dc070","pos":61,"input":"## <font color='orange'>Regularization</font>","cell_type":"markdown"}
{"type":"cell","id":"87e4d1","pos":94,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=1, v0=2.5)\n#qt12 = np.array((np.ones(l.N),)*3)\nN_twist = 12\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        qt12 = l.iterate(qt12, plot=False, N_twist=N_twist)","cell_type":"code","exec_count":0}
{"type":"cell","id":"8d6907","pos":22,"input":"# Test the series expansion\ne, lam = gaudin(0.001)\n(e - (-1.0 + np.pi**2/12/(lam)**2 + np.pi**2/24/(lam)**3))","output":{"0":{"data":{"text/plain":"1.5206977899140384e-09"},"output_type":"execute_result","exec_count":6}},"cell_type":"code","exec_count":6}
{"type":"cell","id":"8da4dc","pos":106,"input":"n/2, (1-np.diag(R)[:N])*b.L","cell_type":"code","exec_count":0}
{"type":"cell","id":"90c84b","pos":7,"input":"## Alternative Formulation","cell_type":"markdown"}
{"type":"cell","id":"9b3013","pos":86,"input":"import homogeneous;reload(homogeneous)\nh = homogeneous.Homogeneous()\ndelta = 1.0\nmu_eff = 1.0\nm = 1.0\nmus_eff = [mu_eff]*2\nv_0, (na, nb), (mua, mub) = h.get_BCS_v_n_e(delta=delta, mus_eff=mus_eff)\nv_0_, n_, mu_, e_0_ = homogeneous.get_BCS_v_n_e(delta=delta, mu_eff=mu_eff)\nassert np.allclose([v_0, na+nb, (mua+mub)/2], [v_0_, n_, mu_])","cell_type":"code","exec_count":0}
{"type":"cell","id":"9d5b37","pos":58,"input":"This plot shows that we need about $2^5=32$ points in the twist average to accurately determine the results.","cell_type":"markdown"}
{"type":"cell","id":"9dfa9a","pos":13,"input":"## <font color='green'>Homogeneous Matter</font>","cell_type":"markdown"}
{"type":"cell","id":"9fb9c5","pos":23,"input":"## <font color='orange'>The Local Density Approximation (LDA) at T=0</font>","cell_type":"markdown"}
{"type":"cell","id":"a09f61","pos":26,"input":"## <font color='green'>LDA at finite T</font>","cell_type":"markdown"}
{"type":"cell","id":"a75002","pos":36,"input":"### <font color='green'>Single-Particle Hamiltonian Matrix</font>","cell_type":"markdown"}
{"type":"cell","id":"aaa179","pos":29,"input":"To match our review paper...\n\n$$\n  n_+ = \n  1 - \\frac{\\epsilon^+_k}{E_k}\\bigl(f(\\omega_-) - f(\\omega_+)\\bigr)\\\\\n  = \n  1 - \\frac{\\epsilon^+_k}{E_k}(1 - 2\\bar{f}(E_k))\\\\\n  = \n  1 - \\frac{\\epsilon^+_k}{E_k} \n  + 2\\frac{\\epsilon^+_k}{E_k}\\bar{f}(E_k))\n$$\n**I changed the first $\\omega_-$ to $\\omega_+$ for $\\bar{f}(E_k)$:**\n\n$$\n  \\bar{f}(E_k) = \\frac{f(E_k + \\epsilon_+) + f(E_k - \\epsilon_-)}{2}\\\\\n  1 - 2\\bar{f}(E_k)\n  = f(\\omega_-) - f(\\omega_+)\n$$","cell_type":"markdown"}
{"type":"cell","id":"aafded","pos":41,"input":"The RHS matrix can be further decompose into three matrices:\n$$\n \\begin{pmatrix}\n    \\sum_{k}{e^{ikx_1}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_1}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_1}e^{-iky_N}f(k)}\\\\\n    \\sum_{k}{e^{ikx_2}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_2}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_2}e^{-iky_N}f(k)}\\\\\n    \\vdots\\\\\n    \\sum_{k}{e^{ikx_N}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_N}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_N}e^{-iky_N}f(k)}\\\\\n  \\end{pmatrix}=\n   \\begin{pmatrix}\n    e^{ik_1x_1} & e^{ik_2x_1}&...&e^{ik_Nx_1}\\\\\n    e^{ik_1x_2} & e^{ik_2x_2}&...&e^{ik_Nx_2}\\\\\n    \\vdots\\\\\n    e^{ik_1x_N} & e^{ik_2x_N}&...&e^{ik_Nx_N}\\\\\n  \\end{pmatrix}\n  \\begin{pmatrix}\n    f(k_1) & 0&...&0\\\\\n    0 & f(k_2)&...&0\\\\\n    \\vdots\\\\\n    0 & 0&...&f(k_N)\\\\\n  \\end{pmatrix}\n \\begin{pmatrix}\n    e^{-ik_1y_1} & e^{-ik_1y_2}&...&e^{-ik_1y_N}\\\\\n    e^{-ik_2y_1} & e^{-ik_2y_2}&...&e^{-ik_2y_N}\\\\\n    \\vdots\\\\\n    e^{-ik_Ny_1} & e^{-ik_Ny_2}&...&e^{-ik_Ny_N}\\\\\n  \\end{pmatrix}\n$$\n","cell_type":"markdown"}
{"type":"cell","id":"abd7b7","pos":24,"input":"The solution for homogeneous states within HFB theory is called the Local Density Approximation (LDA).  For non-uniform systems, one treats each region of space as if it were locally homogeneous, using this solution with a spatially dependent chemical potential.  Here we present the equations for the LDA for a homogeneous gas of equal numbers of two fermionic species interacing with a delta-function interactions $V(x-y) = v_0\\delta(x-y)$.  The gap equations have the form (see for example [Quick:1993]):\n\n$$\n  \\Delta = v_0 \\nu = \\frac{v_0}{2}\\int\\frac{\\d{k}}{2\\pi}\\;\\frac{\\Delta}{\\sqrt{\\epsilon_+^2 + \\Delta^2}},\\quad\n  n_+ = \\frac{N_a + N_b}{L} = \\int\\frac{\\d{k}}{2\\pi}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right],\\quad\n  \\epsilon_+ = \\frac{\\hbar^2k^2}{2m} - \\frac{1}{2}n_+v_0 - \\mu = \\frac{\\hbar^2k^2}{2m} - \\mu_{\\text{eff}},\\\\\n  \\frac{E}{L} = \n  \\int\\frac{\\d{k}}{2\\pi} \\frac{\\hbar^2k^2}{2m}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right]\n  - v_0(n_an_b + \\nu^\\dagger\\nu)\n  = \n  \\int\\frac{\\d{k}}{2\\pi} \\frac{\\hbar^2k^2}{2m}\n    \\left[1 - \\frac{\\epsilon_+}{\\sqrt{\\epsilon_+^2 + \\abs{\\Delta}^2}}\\right]\n  - \\frac{v_0 n_+^2}{4}\n  - \\frac{\\abs{\\Delta}^2}{v_0}.\n$$\n\nwhere $\\mu = \\mu_0 - V_\\text{ext}$ is the effective local chemical potential.  These are easily solved by choosing $\\Delta$ and $\\mu_\\mathrm{eff}$, then integrating to determine $v_0$, $n_+$, and $\\mu$.\n\n[Quick:1993]: http://dx.doi.org/10.1103/PhysRevB.47.11512 'R. M. Quick, C. Esebbag, and M. de Llano, \"BCS theory tested in an exactly solvable fermion fluid\", Phys. Rev. B 47, 11512--11514 (1993)'","cell_type":"markdown"}
{"type":"cell","id":"acacff","pos":89,"input":"L = 20.0\nkF = 50.0/L\nEF = kF**2/2\nmu = 9.5*EF\nt = 0.1*EF\nt, mu","cell_type":"code","exec_count":0}
{"type":"cell","id":"acdd3e","pos":52,"input":"%pylab inline --no-import-all\nimport bcs;reload(bcs)\nimport homogeneous;reload(homogeneous)\n\ndelta = 1.0\nmu_eff = 1.0\nm = 1.0\nv_0, n, mu, e_0 = homogeneous.get_BCS_v_n_e(delta=delta, mu_eff=mu_eff)\n\nN_twist = 2\n\ndef get_err(N, L, N_twist=1):\n    b = bcs.BCS(T=0, N=N, L=L)\n    R = b.get_R(mus=(mu_eff, mu_eff), delta=delta, N_twist=N_twist)\n    na = np.diag(R)[:N]/b.dx\n    nb = (1 - np.diag(R)[N:])/b.dx\n    kappa = - np.diag(R[:N, N:])/b.dx\n\n    k_max = np.pi*N/L\n    dn_UV = 2*b.m**2*delta**2/3/np.pi/k_max**3 + 8*b.m**3*mu_eff*delta**2/5/np.pi/k_max**5\n    dd_UV = v_0*b.m*delta/np.pi/k_max + 2*v_0*b.m**2*mu_eff/3/np.pi/k_max**3\n    return [[na[0].real + nb[0].real, -v_0*kappa[0].real],[dn_UV, dd_UV]]\n\ndef get_errs(Ns, Ls, N_twist=1):\n    Ns, Ls = np.asarray(Ns), np.asarray(Ls)\n    res_NL = []\n    res_UV = []\n    for L in Ls:\n        res_NL_ = []\n        res_UV_ = []\n        for N in Ns:\n            n_d, d_UV = get_err(N=N, L=L, N_twist=N_twist)\n            res_NL_.append(n_d)\n            res_UV_.append(d_UV)\n        res_NL.append(res_NL_)\n        res_UV.append(res_UV_)\n    return np.array([res_NL, res_UV])","output":{"0":{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n"}},"cell_type":"code","exec_count":8}
{"type":"cell","id":"aea001","pos":104,"input":"$$\n  \\frac{\\d{k}}{2\\pi} \\equiv \\frac{1}{L}, \\qquad\n  \\int \\frac{\\d{k}}{2\\pi} \\equiv \\frac{1}{L}\\sum_{k}\n$$","cell_type":"markdown"}
{"type":"cell","id":"af5428","pos":60,"input":"_l_n, = plt.loglog(Ls, abs(n_-n)/n, '--+', label='$n$', alpha=0.5)\n_l_d, = plt.loglog(Ls, abs(d_-delta)/delta, '--o', label=r'$\\Delta$', alpha=0.5)\nplt.loglog(Ls, abs(1./Ls**3)/n, ':', c=_l_n.get_c())\nplt.loglog(Ls, abs(1./Ls**3)/delta, ':', c=_l_d.get_c())\n\nplt.ylabel('Rel err')\nplt.xlabel('L')\nplt.legend()","output":{"0":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7fdeeb7d7ba8>"},"output_type":"execute_result","exec_count":13},"1":{"data":{"image/png":"94ae3eb0cc986c1aec6b94d89f93c72310baa817"},"metadata":{"image/png":{"height":265,"width":396}},"output_type":"execute_result","exec_count":13}},"cell_type":"code","exec_count":13}
{"type":"cell","id":"afc7b2","pos":64,"input":"#### More details","cell_type":"markdown"}
{"type":"cell","id":"b23b31","pos":16,"input":"For inhomogeneous systems, the same approach works, but one cannot use momentum as a good quantum number.  Thus, the Hamiltonian $\\mat{H}$ will simply need to be diagonalized into a complete set of states:\n\n$$\n  \\mat{H}_0\\cdot \\vect{U}_{\\pm n} = \\vect{U}_{\\pm n}E_{\\pm n}, \\qquad\n  \\vect{U}_{\\pm n} = \n  \\begin{pmatrix}\n    u_{\\pm n} \\\\\n    v^*_{\\pm n}\n  \\end{pmatrix}.\n$$\n\nThe columns of the matrix $\\mat{U}$ are these eigenvectors.","cell_type":"markdown"}
{"type":"cell","id":"b5390b","pos":82,"input":"l = Lattice(T=0.0, N=N, L=L, v0=v_0, V0=0)\nqT = (mu, mu) + (mu_eff*np.ones(l.N),)*2 + (np.ones(l.N)*delta,)\nmax_iteration = 5\nwith NoInterrupt() as interrupted:\n    while max_iteration > 0:\n        max_iteration -= 1\n        qT = l.iterate_full(qT, plot=False, N_twist=np.inf,na_avg=n/2, nb_avg=n/2, abs_tol=1e-2)","output":{"0":{"data":{"text/plain":"'0.999438015189, 0.422640518602, 0.422640518602'"},"output_type":"execute_result","exec_count":20}},"cell_type":"code","exec_count":20}
{"type":"cell","id":"b6c8b8","pos":38,"input":"\n$$\n  U_{kx} = \\frac{1}{\\sqrt{N}}e^{-\\I k x}, \\qquad\n  \\mat{U}^{-1} = \\mat{U}^\\dagger.\n$$","cell_type":"markdown"}
{"type":"cell","id":"b71049","pos":84,"input":"## Computing $t$","cell_type":"markdown"}
{"type":"cell","id":"b80698","pos":19,"input":"The homogeneous equations for a two-component Fermi gas with short-range interactions $v_0 \\delta(x-y)$ are known exactly from the Gaudin equations [Gaudin:1967] which give the numerical solution [Casas:1991]:\n\n$$\n  F(x) = 2 - \\frac{K}{\\pi}\\int_{-1}^{1} dy\\; \\frac{F(y)}{1+K^2(x-y)^2}\\\\\n  \\frac{1}{\\lambda}= \\frac{K}{\\pi}\\int_{-1}^{1}dy\\;F(y)\\\\\n  \\frac{E_0(N)/N}{\\abs{E_0(2)/2}} = -1 + \\frac{4}{\\pi}K^3\\lambda\\int_{-1}^{1}dy\\; y^2F(y),\n$$\n\nwhere $E_0(2) = -mv_0^2/4\\hbar^2$ is the two-body binding energy and $\\lambda = mv_0/\\hbar^2/\\rho$ is the dimensionless coupling constant. This solution is only valid in homogeneous matter, but should give some idea of how well mean-field techniques work.  A direct comparison with the BCS solution [Quick:1993] shows that there are significant disagreements in the strong-coupling regime $0 < \\lambda ^{-1} < 1$.\n\n[Gaudin:1967]: http://dx.doi.org/10.1016/0375-9601(67)90193-4 'M. Gaudin, \"Un Systeme a Une Dimension de Fermions en Interaction\", Phys. Lett. A24(1), 55-56 (1967)'\n[Casas:1991]: http://dx.doi.org/10.1103/PhysRevA.44.4915 'M. Casas, C. Esebbag, A. Extremera, J. M. Getino, M. de Llano, A. Plastino, and H. Rubio, \"Cooper pairing in a soluble one-dimensional many-fermion model\", Phys. Rev. A 44(8), 4915--4922 (1991)'\n[Quick:1993]: http://dx.doi.org/10.1103/PhysRevB.47.11512 'R. M. Quick, C. Esebbag, and M. de Llano, \"BCS theory tested in an exactly solvable fermion fluid\", Phys. Rev. B 47, 11512--11514 (1993)'\n\nTo compare results note that [Quick:1993] and [Casas:1991] use the dimensionless $\\epsilon = E(N)/\\abs{E_0(N)}$ where $E_0(N)$ is the energy of $N$ particles in the zero-density limit.  I.e. where one has $N/2$ dimers, each with energy $E_0(2)$.  Thus $E_0(N) = E_0(2) N/2$.  The interaction strength is expressed in terms of $\\lambda^{-1} \\propto n$.","cell_type":"markdown"}
{"type":"cell","id":"b8ede6","pos":70,"input":"We now consider the [Kronig–Penney model](https://en.wikipedia.org/wiki/Particle_in_a_one-dimensional_lattice#Kronig–Penney_model) for a potential barrier of width $b$ separating wells by height $V_0>0$ and period $L$.  The solution for the lowest band ($E<V_0$) is:\n\n$$\n  \\cos k_B L = \\cosh \\kappa b\\cos k (L-b)\n  + \\frac{\\kappa_0^2 - k^2}{2k\\kappa_0}\\sinh\\kappa_0 b\\sin k(L-b), \\\\\n  k = \\frac{\\sqrt{2mE}}{\\hbar}, \\qquad\n  \\kappa_0 = \\frac{\\sqrt{2m(V_0-E)}}{\\hbar}.\n$$\n\nThere may be additional bands with $E<V_0$ but in general, higher bands will have $E>V_0$:\n\n$$\n  \\cos k_B L = \\cos k_0 b\\cos k (L-b)\n  - \\frac{k_0^2 + k^2}{2kk_0}\\sin k_0 b\\sin k(L-b), \\qquad\n  k_0 = \\frac{\\sqrt{2m(E-V_0)}}{\\hbar}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"bbbcb5","pos":67,"input":"To match the result from equation 305, the above can be mutiplied by a factor for both side to get:\n$$\n\\frac{8\\pi}{g_e}=\\frac{2m}{\\hbar^2 a} - \\frac{4mk_c}{\\hbar^2\\pi}\n$$\nBy setting $m=\\hbar=1$,it becomes:\n$$\n\\frac{8\\pi}{g_e}=\\frac{2}{a} - \\frac{4k_c}{\\pi}\n$$","cell_type":"markdown"}
{"type":"cell","id":"bc294a","pos":83,"input":"import mmfutils\nmmfutils.__version__","cell_type":"code","exec_count":0}
{"type":"cell","id":"bf96e9","pos":98,"input":"from scipy.optimize import leastsq\n\ndef f(q):\n    t, E0 = q\n    return (d[:cells] - E0 - sorted(2*t*(1-np.cos(k_bloch*L_cell))))\n\n(t, E0) = leastsq(f, x0=(0.0000001, -1))[0]\nplt.plot(f((t, E0)))\nprint(t, E0)","cell_type":"code","exec_count":0}
{"type":"cell","id":"c1381d","pos":59,"input":"Ls = np.linspace(10.0, 30.0, 20)\nres = []\nfor L in Ls:\n    b = bcs.BCS(T=0, N=2**10, L=L)\n    N = b.N\n    R = b.get_R(mus=(mu_eff, mu_eff), delta=delta)\n    na = np.diag(R)[:N]/b.dx\n    nb = (1 - np.diag(R)[N:])/b.dx\n    kappa = - np.diag(R[:N, N:])/b.dx\n    #na, nb, kappa\n    res.append((na[0].real + nb[0].real, -v_0*kappa[0].real))\nn_, d_ = np.array(res).T","cell_type":"code","exec_count":12}
{"type":"cell","id":"c19953","pos":40,"input":"$$\n  \\begin{pmatrix}\n    \\vec{T}\\psi(x)|_{x=x_1}\\\\\n    \\vec{T}\\psi(x)|_{x=x_2}\\\\\n    \\vdots\\\\\n    \\vec{T}\\psi(x)|_{x=x_N}\\\\\n  \\end{pmatrix} = \\frac{1}{N}\\begin{pmatrix}\n    \\sum_{k}{e^{ikx_1}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_1}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_1}e^{-iky_N}f(k)}\\\\\n    \\sum_{k}{e^{ikx_2}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_2}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_2}e^{-iky_N}f(k)}\\\\\n    \\vdots\\\\\n    \\sum_{k}{e^{ikx_N}e^{-iky_1}f(k)} & \\sum_{k}{e^{ikx_N}e^{-iky_2}f(k)}&...&\\sum_{k}{e^{ikx_N}e^{-iky_N}f(k)}\\\\\n  \\end{pmatrix}\n \\begin{pmatrix}\n    \\psi(y_1)\\\\\n    \\psi(y_2)\\\\\n    \\vdots\\\\\n    \\psi(y_N)\\\\\n  \\end{pmatrix}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"c2b6f0","pos":72,"input":"Define as for the optical lattice potential\n\n$$\n  k_0 = \\frac{\\pi}{L}, \\qquad E_R = \\frac{\\hbar^2 k_0^2}{2m}.\n$$","cell_type":"markdown"}
{"type":"cell","id":"c2cfdd","pos":35,"input":"## BCS Code","cell_type":"markdown"}
{"type":"cell","id":"c2f9c8","pos":74,"input":"In the revised paper, they have $2mtd^2 = 0.16$ and $Lk_F = 20-55$ which corresponds to:\n\n$$\n  \\frac{t}{E_R} = \\frac{0.16}{\\pi^2} = 0.0162, \\qquad\n  h \\approx 1.69, \\qquad\n  V_0 = 4h^2E_R = 4h^2E_F\\left(\\frac{\\pi}{d k_F}\\right)^2 = 0.28-0.037,\\\\\n  \\frac{\\Delta}{E_F} \\approx 8 - 24, \\qquad\n  \\frac{\\mu^{\\uparrow}}{E_F} \\approx 4 - 11, \\qquad\n  \\frac{\\mu^{\\downarrow}}{E_F} \\approx -4 - -12.5.\n$$","cell_type":"markdown"}
{"type":"cell","id":"c676f3","pos":71,"input":"In the tight-binding limit, we expect the first form $E < V_0$ and the dispersion to have the form:\n\n$$\n  E(k_B) \\approx E_0 + 2t(1-\\cos k_B L).\n$$","cell_type":"markdown"}
{"type":"cell","id":"c80d98","pos":105,"input":"d, UV = np.linalg.eigh(H)\nself = b\nu = UV[:N, :N]\nv = UV[N:, :N].conj()\nk2 = (np.sqrt(d**2 - delta**2) + mu_eff)*2*b.m/b.hbar**2\nplt.plot(np.sqrt(k2[:N]), (abs(u)**2).sum(axis=0), '+');\nplt.plot(k, n/2);","cell_type":"code","exec_count":0}
{"type":"cell","id":"c9750a","pos":30,"input":"## <font color='green'>3D case</font>","cell_type":"markdown"}
{"type":"cell","id":"c97c41","pos":102,"input":"delta = 10.0\nmu_eff = 1.0\nb = bcs.BCS(T=0, N=128, L=10.0)\nH = b.get_H(mus=(mu_eff, mu_eff), delta=delta)\nk = np.fft.fftshift(b.k)\nep = (b.hbar*k)**2/2/b.m - mu_eff\nem = 0\nE = np.sqrt(ep**2 + delta**2)\nwp = em + E\nwm = em - E\nassert np.allclose(np.linalg.eigvalsh(H),\n                   sorted(np.concatenate([wp, wm])))\n\nn = 1 - ep/E\nplt.plot(k, n)\nnp.trapz(n, k/2/np.pi)","cell_type":"code","exec_count":0}
{"type":"cell","id":"cbc36e","pos":81,"input":"# Test - reproduce homogeneous results\nimport homogeneous\ndelta = 1.0\nmu_eff = 1.0\nv_0, n, mu, e_0 = homogeneous.get_BCS_v_n_e(delta=delta, mu_eff=mu_eff)\n\nL = 0.46\nN = 2**8\nN_twist = 2**5\nfor b in [bcs.BCS(T=0, N=N, L=L),\n          Lattice(T=0.0, N=N, L=L, v0=v_0, V0=0)]:\n    R = b.get_R(mus=(mu_eff, mu_eff), delta=delta, N_twist=N_twist)\n    na = np.diag(R)[:N]/b.dx\n    nb = (1 - np.diag(R)[N:])/b.dx\n    kappa = np.diag(R[:N, N:])/b.dx\n    print((n, na[0].real + nb[0].real), (delta, v_0*kappa[0].real))","output":{"0":{"name":"stdout","output_type":"stream","text":"(0.8450714742610562, 0.8450551128501909) (1.0, 0.9995783316705613)\n"},"1":{"name":"stdout","output_type":"stream","text":"(0.8450714742610562, 0.8450551128501909) (1.0, 0.9995783316705613)\n"}},"cell_type":"code","exec_count":16}
{"type":"cell","id":"cbfc10","pos":73,"input":"%pylab inline --no-import-all\nimport scipy.optimize\nimport scipy as sp\nimport ad.admath\nhbar = k0 = 1.0\nm = 0.5\nER = (hbar*k0)**2/2/m\nL = np.pi/k0\n\nclass KronigPenney(object):\n    def __init__(self, V0, b_L):\n        self.V0 = V0\n        self.b_L = b_L\n        \n    def rhs(self, E_V0, d=0, np=np):\n        V0 = self.V0\n        E = E_V0*V0\n        if d==1:\n            E = ad.adfloat(E)\n            np = ad.admath\n        else:\n            E = E + 0j\n        b = self.b_L*L\n        k = np.sqrt(2*m*E)/hbar\n        kappa0 = np.sqrt(2*m*(V0-E))/hbar\n        P = (kappa0**2 - k**2)/2/k/kappa0\n        res = (np.cosh(kappa0*b)*np.cos(k*(L-b)) \n               + P*np.sinh(kappa0*b)*np.sin(k*(L-b)))\n        if d==0:\n            return res\n        elif d==1:\n            return res.d(E)\n\n    def get_E0_V0(self, E_V0_max=1-1e-12):\n        def f(E0_V0):\n            return self.rhs(E0_V0) - 1\n        return sp.optimize.brentq(f, 1e-12, E_V0_max)\n    \n    def get_t(self, E0_V0=None):\n        if E0_V0 is None:\n            E0_V0 = p.get_E0_V0()\n        drhs = self.rhs(E0_V0, d=1)\n        t_V0 = -0.5/drhs\n        return t_V0\n    \n#p = KronigPenney(V0=35.6879098, b_L=0.1)\np = KronigPenney(V0=15.2196051, b_L=0.9)\n#p = KronigPenney(V0=67.3944700, b_L=0.1)\nkFL, DeltaEF = 20., 8.\nkFL, DeltaEF = 55., 24. \n\nkF = kFL/L\nEF = (hbar*kF)**2/2/m\nDelta = DeltaEF*EF\n\nE0_V0 = p.get_E0_V0()\nprint(E0_V0/p.V0)\nt = p.get_t(E0_V0=E0_V0)\nprint(t)\nprint(2*m*t*L**2)\nE_V0 = E0_V0 + np.linspace(0,1000*t/p.V0,1000)\nkL = np.linspace(0, np.pi, 100)\nE_unit = EF\nplt.plot(np.arccos(p.rhs(E_V0)), (E_V0-E0_V0)*p.V0/E_unit)\nplt.plot(kL, 2*t*(1-np.cos(kL))/E_unit)","output":{"0":{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n0.04882595826802876\n0.0162113894193529\n0.16000000036101883\n"},"1":{"name":"stderr","output_type":"stream","text":"/usr/local/lib/python3.6/dist-packages/scipy/optimize/zeros.py:510: ComplexWarning: Casting complex values to real discards the imaginary part\n  r = _zeros._brentq(f,a,b,xtol,rtol,maxiter,args,full_output,disp)\n/usr/local/lib/python3.6/dist-packages/numpy/core/numeric.py:492: ComplexWarning: Casting complex values to real discards the imaginary part\n  return array(a, dtype, copy=False, order=order)\n"},"2":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fdef159c240>]"},"output_type":"execute_result","exec_count":14},"3":{"data":{"image/png":"5c0f9ec5fafb052377a40c0e115edbb68462e27e"},"metadata":{"image/png":{"height":250,"width":380}},"output_type":"execute_result","exec_count":14}},"cell_type":"code","exec_count":14}
{"type":"cell","id":"d01e74","pos":109,"input":"To run this code, you can use the following Conda environment.","cell_type":"markdown"}
{"type":"cell","id":"d176e0","pos":90,"input":"\nl = Lattice(T=0.000001, N=128, L=10.0, cells=1, v0=2.5)\n#qT = (1.0, 1.0) + (np.ones(l.N),)*3\nN_twist = 1\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        qT = l.iterate_full(qT, plot=False, N_twist=N_twist, \n                            na_avg=0.5, nb_avg=0.5, abs_tol=1e-2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"d77e5d","pos":95,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=1, v0=2.5)\n#qt24 = np.array((np.ones(l.N),)*3)\nN_twist = 24\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        qt24 = l.iterate(qt24, plot=False, N_twist=N_twist)","cell_type":"code","exec_count":0}
{"type":"cell","id":"dd297e","pos":20,"input":"%pylab inline --no-import-all\n\ndef gaudin(K, N=64, tol=1e-6):\n    \"\"\"Return `E, lam` for exact Gaudin solution in box\"\"\"\n    x = np.linspace(-1, 1, N)\n    \n    F0 = 0*x\n    F1 = 2 - F0\n\n    n = 0\n    while abs(F0-F1).max() > tol:\n        F0 = F1\n        F1 = 2.0 - K/np.pi * np.trapz(\n            F0[None, :]/(1+K**2*(x[:,None] - x[None,:])**2), x, axis=1)\n        n += 1\n    lam = np.pi / K / np.trapz(F1, x)\n    e = -1 + 4./np.pi*K**3*lam * np.trapz(x**2*F1, x)\n    return e, lam","output":{"0":{"name":"stdout","output_type":"stream","text":"Populating the interactive namespace from numpy and matplotlib\n"}},"cell_type":"code","exec_count":4}
{"type":"cell","id":"e5346a","pos":63,"input":"To relate with Braaten and Hammer (2006) [Physics Reports 428 (2006) 259 – 390], we identify $g_2 = -v_0$.  (Equations are numbered as in the paper.)  Next, calculate the s-wave scattering $a(g_2, \\Lambda)$ as a function of the interaction strength and cutoff:\n\n\\begin{gather}\n  \\frac{1}{a} - \\frac{2\\Lambda}{\\pi} = \\frac{8\\pi}{g_2} \\tag{305}.\n\\end{gather}\n\nNext, rearrange the gap equation in terms of $8\\pi/g_2$:\n\n$$\n  \\frac{8\\pi}{g_2} = \\frac{1}{a} - \\frac{2\\Lambda}{\\pi} = -\\frac{8\\pi}{2}\\int\\frac{\\d{k}^3}{(2\\pi)^3}\\;\\frac{1}{\\sqrt{\\epsilon_+^2 + \\Delta^2}}.\n$$\n\nNow substitute for your expression of $\\Lambda$.  The divergences should cancel levaing a convergent equation that is valid in the limit of $\\Lambda \\rightarrow \\infty$.  (Since we have not worked this out yet, we work backwards to cancel the divergence.)\n\n$$\n  \\frac{1}{a} = \\frac{2\\Lambda}{\\pi} - \\frac{8\\pi}{2}\\int_{k < k_c}\\frac{\\d{k}^3}{(2\\pi)^3}\\;\\frac{1}{\\sqrt{\\epsilon_+^2 + \\Delta^2}}\n  = \\frac{8\\pi}{2}\\int_{k < k_c}\\frac{\\d{k}^3}{(2\\pi)^3}\\;\\left(\n  \\frac{1}{E_+} - \\frac{1}{\\sqrt{\\epsilon_+^2 + \\Delta^2}}\n  \\right)\\\\\n  E_+ = \\frac{\\hbar^2k^2}{2m}, \\qquad\n  \\Lambda = 2\\pi^2\\int_{k< k_c}\\frac{\\d{k}^3}{(2\\pi)^3}\\;\\frac{1}{E_+}\n          = 2\\pi^2\\int_{k< k_c}\\frac{\\d{k}^3}{(2\\pi)^3}\\;\\frac{2m}{\\hbar^2k^2}\n          = \\frac{2m}{\\hbar^2}k_c\n$$\n\n2. The second improvement due to Aurel Bulgac is to note that you can do the integrals with $1/\\epsilon_+ = 1/(E_+ - \\mu + \\I 0^+)$ instead of $1/E_+$, which improves the order of convergence further.  Basically, this redefines the cutoff in terms of $k_c$ which satisfies:\n\n   $$\n     E_c = \\frac{\\hbar^2k_c^2}{2m} - \\mu\n   $$\n\n   instead of $E_c = \\hbar^2k_c^2/2m$ which is done above, effectively changing the meaning of $\\Lambda$.\n\n3. Aurel's approach works with density dependent $\\mu(x)$ etc.","cell_type":"markdown"}
{"type":"cell","id":"e6e267","pos":25,"input":"<font color='red'>** To perform these integrals numerically, we need to deal with potential singularities.  As $\\Delta \\rightarrow 0$, there is a potential singularity when $\\epsilon_+(k) = 0$ i.e. when $k = k_F$.  This is easily dealt with by breaking the integrand up into regions $(0, k_F) \\cup (k_F, \\infty)$.  One might occasionally have problems with the energy integral at large $k$.** </font>","cell_type":"markdown"}
{"type":"cell","id":"e9732c","pos":9,"input":"# <font color='orange'>BCS Theory</font>","cell_type":"markdown"}
{"type":"cell","id":"ef71c5","pos":12,"input":"Consider diagonalizing the quadratic Hamiltonian\n\n$$\n  \\op{H}_0 = \\op{\\Psi}^\\dagger \\cdot \\mat{M} \\cdot \\op{\\Psi}\n           = \\op{C}^\\dagger\\cdot\\diag{E}\\cdot\\op{C}, \\qquad\n  \\mat{U}^\\dagger\\cdot\\mat{M}\\cdot\\mat{U} = \\diag(E), \\qquad\n  \\op{\\Psi} = \\mat{U} \\cdot \\op{C}.\n$$\n\nThis Hamiltonian is diagonal in terms of the quasi-particle operators $\\op{c}_n$ and so the vacuum state will occupy these (independent) levels with probability $f_\\beta(E_n)$:\n\n$$\n  \\braket{\\op{c}_m^\\dagger\\op{c}_n} = \\delta_{mn}f_\\beta(E_n).\n$$\n\nWe can arrange this in matrix form by noting that $f_\\beta(E) + f_\\beta(-E) = 1$:\n\n$$\n  \\braket{\\op{C}\\op{C}^\\dagger}\n  = \\mat{1} - \\braket{\\op{C}^\\dagger\\op{C}}\n  = \\mat{1} - f_\\beta\\bigl(\\diag(E)\\bigr) = f_\\beta\\bigl(-\\diag(E)\\bigr),\\\\\n  \\braket{\\op{\\Psi}\\op{\\Psi}^\\dagger} \n    = \\mat{U}\\cdot\\braket{\\op{C}\\op{C}^\\dagger}\\cdot\\mat{U}^\\dagger\n    = f_\\beta(-\\mat{M}) = \\mat{1} - f_\\beta(\\mat{M})\n    = \\mat{1} - \\mat{R}.\n$$\n\nFor standard BCS theory, we have \n\n$$\n  \\op{\\Psi} = \\begin{pmatrix}\n    \\op{a}\\\\\n    \\op{b}^\\dagger\n  \\end{pmatrix}, \\qquad\n  \\diag[f_\\beta(-\\mat{M})] = \\begin{pmatrix}\n    \\braket{\\op{a}\\op{a}^\\dagger} = 1-n_a \\\\\n    \\braket{\\op{b}^\\dagger\\op{b}} = n_b\n  \\end{pmatrix}\n$$\n\nfor example.","cell_type":"markdown"}
{"type":"cell","id":"f2bd69","pos":18,"input":"## <font color='orange'> Exact Solution (Gaudin)</font>","cell_type":"markdown"}
{"type":"cell","id":"f30e47","pos":101,"input":"M = np.array([[ep[0], -delta], [-delta, -ep[0]]])\nnp.linalg.eigh(M)[1], np.sqrt((1+ep[0]/E[0])/2)","cell_type":"code","exec_count":0}
{"type":"cell","id":"f5b6a9","pos":103,"input":"k2[:N]","cell_type":"code","exec_count":0}
{"type":"cell","id":"f760a1","pos":56,"input":"2**10*np.pi**2/v_0/m*1e-4","output":{"0":{"data":{"text/plain":"0.45909828128498303"},"output_type":"execute_result","exec_count":10}},"cell_type":"code","exec_count":10}
{"type":"cell","id":"f8725a","pos":6,"input":"Here is how I tend to view the mean-field approximation.  It is not the only way of thinking about things, but satisfies my notion of being well defined and general.  It is based on the following theorem from [Feynman:1998]:\n\n**Theorem:** The thermodynamic potential $F$ of a given system described by the Hamiltonian $\\op{H}$ is bounded:\n\n$$\n  F \\leq F_0 + \\braket{\\op{H} - \\op{H}_0}_0\n$$\n\nwhere $F_0$ is the thermodynamic potential of the system described by the Hamiltonian $\\op{H}_0$ and the average $\\braket{}_0$ is performed with respect to the thermal ensemble of $\\op{H}_0$:\n\n$$\n  \\braket{\\op{A}}_0 = \\frac{\\Tr\\bigl[\\op{A}e^{-\\beta\\op{H}_0}\\bigr]}{\\Tr e^{-\\beta\\op{H}_0}}\n$$\n\nWhat this means is that we can choose any Hamiltonian $\\op{H}_0$ for which we can exactly solve the problem, and use it to obtain a variational upper bound on the thermodynamic potential $F$.  A general strategy is thus to introduce some solvable Hamiltonian $\\op{H}_0$ that depends on some parameters, then choose these parameters so as to minimize the right-hand size of the previous equation.\n\n[Feynman:1998]: http://search.perseusbooksgroup.com/book/paperback/statistical-mechanics/9780201360769 'Richard P. Feynman, \"Statistical Mechanics: A Set of Lectures\", (1998)'","cell_type":"markdown"}
{"type":"cell","id":"fb886d","pos":77,"input":"Prompted by a paper I had to review, here I consider pairing in a system where one component is trapped in an optical lattice with cell-length $L$.  The paper claimed ultra-high critical temperatures due to the modified dispersion.\n\nHere we solve the lattice problem explicitly by modeling the unit cell since we use periodic boundary conditions.  Note: simply solving the 1D problem in a periodic box is not the same as solving the periodic problem in infinite space because the 1D periodic problem neglects Bloch waves of the form:\n\n$$\n  \\psi_{k_b}(x) = e^{\\I k_b x} u(x), \\qquad\n  u(x+L) = u(x), \\qquad \n  \\abs{k_b} < \\frac{\\pi}{L},\n$$\n\nwhere $u(x)$ is periodic.\n\nOne way to understand the need for the Bloch momentum is to note that a periodic box has discrete momenta $k_n = 2\\pi n/L$ with spacing $\\d{k} = 2\\pi/L$.  The Bloch momenta are implement by shifting $k_n \\rightarrow k_n + k_b$.  Thus, the range of Bloch momenta $\\abs{k_b}| \\d{k}/2$ exactly allows one to sample all points in the range $\\d{k}$.\n\nThese Bloch momenta are implemented by averaging the density matrix over the full range of $k_b$ (which we implement as a twist angle $\\theta = k_b L$, $\\abs{\\theta} < \\pi$).","cell_type":"markdown"}
{"type":"cell","id":"fd1e4e","pos":93,"input":"from mmfutils.contexts import NoInterrupt\nl = Lattice(T=0, N=128, L=10.0, mu_a=2.0, cells=1, v0=2.5)\nqt4 = np.array((np.ones(l.N),)*3)\nN_twist = 4\nwith NoInterrupt() as interrupted:\n    while not interrupted:\n        qt4 = l.iterate(qt4, plot=False, N_twist=N_twist)","cell_type":"code","exec_count":0}
{"type":"cell","id":"fe44f8","pos":110,"input":"%%file _environment.yml\nname: _bdg\nchannels:\n  - defaults\n  - conda-forge\ndependencies:\n  - python=3\n  - numpy\n  - scipy>=0.17.1\n  - matplotlib>=1.5\n  - ipykernel        # Use with nb_conda_kernels so jupyter sees this kernel\n  - notebook\n  \n  # For testing\n  - flake8\n  - pytest-cov\n  - pytest-runner\n  #- pylint\n  #- mock\n  #- pep8\n  \n  - pip:\n    - ad\n    - mmf_setup>=0.1.11\n    - mmfutils","cell_type":"code","exec_count":0}
{"type":"file","last_load":1543822208843}
{"type":"settings","kernel":"python3","backend_state":"running","metadata":{"celltoolbar":"Initialization Cell","language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.7"},"nikola":{"category":"","date":"2018-08-21 15:56:35 UTC-07:00","description":"","link":"","slug":"bdg-equations-in-1d","tags":"","title":"BdG Equations in 1D","type":"text"},"toc":{"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"165px"},"skip_h1_title":false,"number_sections":true,"title_cell":"Table of Contents","toc_window_display":true,"base_numbering":1,"toc_section_display":true,"title_sidebar":"Contents","toc_cell":false,"nav_menu":{},"sideBar":true}},"trust":true,"kernel_state":"idle","kernel_usage":{"cpu":0,"memory":73011200}}