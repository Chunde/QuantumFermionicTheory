{"type":"cell","id":"0f80ef","pos":1,"input":"import mmf_setup;mmf_setup.nbinit(hgroot=False)\nfrom mmfutils.contexts import NoInterrupt\nfrom imp import reload  # Python 3.0 - 3.3\nimport numpy as np\nfrom collections import namedtuple","output":{"0":{"data":{"text/html":"<style>.grade {\n   background-color: #66FFCC;\n}\n</style>"},"output_type":"display_data"},"1":{"data":{"application/javascript":""},"output_type":"display_data"},"2":{"data":{"text/html":"<script id=\"MathJax-Element-48\" type=\"math/tex\">\\newcommand{\\vect}[1]{\\mathbf{#1}}\n\\newcommand{\\uvect}[1]{\\hat{#1}}\n\\newcommand{\\abs}[1]{\\lvert#1\\rvert}\n\\newcommand{\\norm}[1]{\\lVert#1\\rVert}\n\\newcommand{\\I}{\\mathrm{i}}\n\\newcommand{\\ket}[1]{\\left|#1\\right\\rangle}\n\\newcommand{\\bra}[1]{\\left\\langle#1\\right|}\n\\newcommand{\\braket}[1]{\\langle#1\\rangle}\n\\newcommand{\\Braket}[1]{\\left\\langle#1\\right\\rangle}\n\\newcommand{\\op}[1]{\\mathbf{#1}}\n\\newcommand{\\mat}[1]{\\mathbf{#1}}\n\\newcommand{\\d}{\\mathrm{d}}\n\\newcommand{\\pdiff}[3][]{\\frac{\\partial^{#1} #2}{\\partial {#3}^{#1}}}\n\\newcommand{\\diff}[3][]{\\frac{\\d^{#1} #2}{\\d {#3}^{#1}}}\n\\newcommand{\\ddiff}[3][]{\\frac{\\delta^{#1} #2}{\\delta {#3}^{#1}}}\n\\newcommand{\\floor}[1]{\\left\\lfloor#1\\right\\rfloor}\n\\newcommand{\\ceil}[1]{\\left\\lceil#1\\right\\rceil}\n\\DeclareMathOperator{\\Tr}{Tr}\n\\DeclareMathOperator{\\erf}{erf}\n\\DeclareMathOperator{\\erfi}{erfi}\n\\DeclareMathOperator{\\sech}{sech}\n\\DeclareMathOperator{\\sgn}{sgn}\n\\DeclareMathOperator{\\order}{O}\n\\DeclareMathOperator{\\diag}{diag}\n\n\\newcommand{\\mylabel}[1]{\\label{#1}\\tag{#1}}\n\\newcommand{\\degree}{\\circ}</script>"},"output_type":"display_data"},"3":{"data":{"text/html":""},"output_type":"display_data"},"4":{"data":{"text/html":"\n<i>\n<p>This cell contains some definitions for equations and some CSS for styling\n  the notebook. If things look a bit strange, please try the following:\n<ul>\n  <li>Choose \"Trust Notebook\" from the \"File\" menu.</li>\n  <li>Re-execute this cell.</li>\n  <li>Reload the notebook.</li>\n</ul>\n</p>\n</i>\n"},"output_type":"display_data"}},"cell_type":"code","exec_count":8}
{"type":"cell","id":"4ed512","pos":0,"input":"# Homogenous Quantum Turbulence\nHere I am trying to implement a simple mode of quantum vertex based on my very imcomplete understanding and poor insight.","cell_type":"markdown"}
{"type":"cell","id":"69f59b","pos":6,"input":"## Turbulence","cell_type":"markdown"}
{"type":"cell","id":"8444de","pos":3,"input":"class HomogeneousTurbulence(object):\n    T = 0.0\n    def __init__(self, **kw):\n        self.__dict__.update(kw)\n\n    def f(self, E):\n        if self.T == 0:\n            return (1+np.sign(-E))/2.0\n        else:\n            return 1./(1+np.exp(E/self.T))\n\n    def quad(f, kF=None, k_0=0, k_inf=np.inf, limit=1000):\n        if kF is None:\n            res, err = sp.integrate.quad(f, k_0, k_inf)\n        else:\n            res0, err0 = sp.integrate.quad(f, k_0, kF)\n            res1, err1 = sp.integrate.quad(f, kF, k_inf, limit=limit)\n            res = res0 + res1\n            err = max(err0, err1)\n        if abs(err) > 1e-6 and abs(err/res) > 1e-6:\n            warnings.warn(\n                \"Gap integral did not converge: res, err = %g, %g\" % (res, err))\n        return 2*res   # Accounts for integral from -inf to inf    \n\n    def get_es(self, k, mus_eff):\n        return (k**2/2.0/m - mus_eff[0],\n                k**2/2.0/m - mus_eff[1])\n\n    Results = namedtuple('Results', ['e_p', 'E', 'w_p', 'w_m'])\n\n    def get_res(self, k, mus_eff, delta):\n        e_a, e_b = self.get_es(k, mus_eff=mus_eff)\n        e_p, e_m = (e_a + e_b)/2, (e_a - e_b)/2\n        E = np.sqrt(e_p**2 + abs(delta)**2)\n        w_p, w_m = e_m + E, e_m - E\n        args = dict(locals())\n        return self.Results(*[args[_n] for _n in self.Results._fields])\n\n    def get_BCS_v_n_e(self, delta, mus_eff):\n        \"\"\"Return `(v_0, n, mu, e)` for the 1D BCS solution at T=0.\"\"\"\n        kF = np.sqrt(2*max(0, max(mus_eff)))\n\n        def gap_integrand(k):\n            res = self.get_res(k=k, mus_eff=mus_eff, delta=delta)\n            return (self.f(res.w_m) - self.f(res.w_p))/res.E\n\n        v_0 = 4*np.pi / quad(gap_integrand, kF)\n\n        def np_integrand(k):\n            \"\"\"Density n_a + n_b\"\"\"\n            res = self.get_res(k=k, mus_eff=mus_eff, delta=delta)\n            n_p = 1 - res.e_p/res.E*(self.f(res.w_m) - self.f(res.w_p))\n            return n_p\n\n        def nm_integrand(k):\n            \"\"\"Density n_a - n_b\"\"\"\n            res = self.get_res(k=k, mus_eff=mus_eff, delta=delta)\n            n_m = self.f(res.w_p) - self.f(-res.w_m)\n            return n_m\n\n        n_m = quad(nm_integrand, kF) / 2/np.pi\n        n_p = quad(np_integrand, kF) / 2/np.pi\n        n_a = (n_p + n_m)/2.0\n        n_b = (n_p - n_m)/2.0\n        ns = np.array([n_a, n_b])\n        mus = mus_eff - np.array([n_b, n_a])*v_0\n\n        return namedtuple('BCS_Results', ['v_0', 'ns', 'mus'])(v_0, ns, mus)","cell_type":"code","exec_count":9}
{"type":"cell","id":"86d079","pos":1.5,"input":"## Regularization\nFor 1D homogenous case, I will use the relatin between the scattering length and the effective potential strength:\n$$\n\\frac{8\\pi}{g_e}=\\frac{2}{a} - \\frac{4k_c}{\\pi}\n$$\n\nwhere $g_e(k_c)$ is a function depends on $k_c$","cell_type":"markdown"}
{"type":"cell","id":"b8cffb","pos":4,"input":"### BCS Code","cell_type":"markdown"}
{"type":"cell","id":"de4d32","pos":7,"input":"","cell_type":"code"}
{"type":"cell","id":"e2bd99","pos":5,"input":"def get_BCS_v_n_e(delta, mu_eff):\n    m = hbar = 1.0\n    kF = np.sqrt(2*m*max(0, mu_eff))/hbar\n\n    def gap_integrand(k):\n        e_p = (hbar*k)**2/2.0/m - mu_eff\n        return 1./np.sqrt(e_p**2 + abs(delta)**2)\n\n    v_0 = 4*np.pi / quad(gap_integrand, kF)\n\n    def n_integrand(k):\n        \"\"\"Density\"\"\"\n        e_p = (hbar*k)**2/2.0/m - mu_eff\n        denom = np.sqrt(e_p**2 + abs(delta)**2)\n        return (denom - e_p)/denom\n\n    n = quad(n_integrand, kF) / 2/np.pi\n\n    def e_integrand(k):\n        \"\"\"Energy\"\"\"\n        e_p = (hbar*k)**2/2.0/m - mu_eff\n        denom = np.sqrt(e_p**2 + abs(delta)**2)\n        return (hbar*k)**2/2.0/m * (denom - e_p)/denom\n    e = quad(e_integrand, kF) / 2/np.pi - v_0*n**2/4.0 - abs(delta)**2/v_0\n\n    mu = mu_eff - n*v_0/2\n\n    return namedtuple('BCS_Results', ['v_0', 'n', 'mu', 'e'])(v_0, n, mu, e)\n\n\ndef BCS(mu_eff, delta=1.0):\n    m = hbar = 1.0\n    v_0, n, mu, e = get_BCS_v_n_e(delta=delta, mu_eff=mu_eff)\n    lam = m*v_0/n/hbar**2\n    # Energy per-particle\n    E_N = e/n\n    # Energy per-particle for 2 particles\n    E_2 = -m*v_0**2/4.0 / 2.0\n    E_N_E_2 = E_N/abs(E_2)\n    return E_N_E_2, lam\n","cell_type":"code","exec_count":10}
{"type":"cell","id":"eb188d","pos":2,"input":"import homogeneous;reload(homogeneous)\nh = homogeneous.Homogeneous1D()\ndelta = 1.0\nmu_eff = 1.0\nm = 1.0\nmus_eff = [mu_eff]*2\nv_0, (na, nb), (mua, mub) = h.get_BCS_v_n_e(delta=delta, mus_eff=mus_eff)\nv_0_, n_, mu_, e_0_ = homogeneous.get_BCS_v_n_e(delta=delta, mu_eff=mu_eff)\nassert np.allclose([v_0, na+nb, (mua+mub)/2], [v_0_, n_, mu_])","cell_type":"code","exec_count":6}
{"type":"file","last_load":1543868547239}
{"type":"settings","kernel":"python3","backend_state":"running","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.4"}},"kernel_state":"idle","kernel_usage":{"cpu":0,"memory":73248768},"trust":true}